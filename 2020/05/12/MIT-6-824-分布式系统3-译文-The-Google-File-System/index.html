<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xavierx.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="The Google File System，GFS，是google设计的大型分布式存储系统，该论文发布与2003年，虽然已经过去了近20年，google也与2013年发布了Colossus作为GFS的替代品的下一代文件系统，但是GFS中的一些设计依然值得我们学习。 导读大型分布式文件系统难在哪里？ 性能 –&gt; 文件分散的存储在不同的设备上，如何保障读写性能？ 容错 –&gt; 我们拥有成千">
<meta property="og:type" content="article">
<meta property="og:title" content="[MIT-6.824-分布式系统3]译文 The Google File System">
<meta property="og:url" content="https://xavierx.cn/2020/05/12/MIT-6-824-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F3-%E8%AF%91%E6%96%87-The-Google-File-System/index.html">
<meta property="og:site_name" content="Xavier&#39;s Blog">
<meta property="og:description" content="The Google File System，GFS，是google设计的大型分布式存储系统，该论文发布与2003年，虽然已经过去了近20年，google也与2013年发布了Colossus作为GFS的替代品的下一代文件系统，但是GFS中的一些设计依然值得我们学习。 导读大型分布式文件系统难在哪里？ 性能 –&gt; 文件分散的存储在不同的设备上，如何保障读写性能？ 容错 –&gt; 我们拥有成千">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://images.haishenming.xyz/blog/20200514101848.png">
<meta property="article:published_time" content="2020-05-12T03:11:10.000Z">
<meta property="article:modified_time" content="2021-07-16T03:35:26.993Z">
<meta property="article:author" content="Xavier">
<meta property="article:tag" content="MIT">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="译文">
<meta property="article:tag" content="论文">
<meta property="article:tag" content="GFS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.haishenming.xyz/blog/20200514101848.png">

<link rel="canonical" href="https://xavierx.cn/2020/05/12/MIT-6-824-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F3-%E8%AF%91%E6%96%87-The-Google-File-System/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>[MIT-6.824-分布式系统3]译文 The Google File System | Xavier's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Xavier's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/05/12/MIT-6-824-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F3-%E8%AF%91%E6%96%87-The-Google-File-System/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [MIT-6.824-分布式系统3]译文 The Google File System
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-12 11:11:10" itemprop="dateCreated datePublished" datetime="2020-05-12T11:11:10+08:00">2020-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>The Google File System</code>，<code>GFS</code>，是google设计的大型分布式存储系统，该论文发布与2003年，虽然已经过去了近20年，google也与2013年发布了<code>Colossus</code>作为<code>GFS</code>的替代品的下一代文件系统，但是<code>GFS</code>中的一些设计依然值得我们学习。</p>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><h3 id="大型分布式文件系统难在哪里？"><a href="#大型分布式文件系统难在哪里？" class="headerlink" title="大型分布式文件系统难在哪里？"></a>大型分布式文件系统难在哪里？</h3><ul>
<li>性能 –&gt; 文件分散的存储在不同的设备上，如何保障读写性能？</li>
<li>容错 –&gt; 我们拥有成千上万的机器和硬盘，不可避免会出现读写错误的情况，这时候怎么办？</li>
<li>一致性 –&gt; 如果使用冗余的方式进行容错，如何保证多机数据的一致性？</li>
<li>……</li>
</ul>
<h3 id="GFS做了什么？"><a href="#GFS做了什么？" class="headerlink" title="GFS做了什么？"></a>GFS做了什么？</h3><p>快速存取大量数据</p>
<ul>
<li>全局（Global） –&gt; 所有设备构成一个统一的全局文件系统</li>
<li>分片（sharding） –&gt; 文件可以被分割存储在不同的设备上，以方便设置冗余，突破单个磁盘存储容量限制，同时也可以提升存取速度。</li>
<li>自动恢复（automatic recovery） –&gt; 大型存储机器中的机器故障可以自动恢复而无需人为干预。</li>
<li>单一数据中心（single data center） –&gt; 一套GFS只在单一的数据中心运行，而不考虑多地共享数据。因此不用考虑远距离的数据共享问题。</li>
<li>大型文件顺序读写 –&gt; 为大型文件顺序读写设计，而区别于小文件随机读写系统。</li>
</ul>
<p>下面是原文和译文</p>
<h1 id="The-Google-File-System"><a href="#The-Google-File-System" class="headerlink" title="The Google File System"></a>The Google File System</h1><p>Google 文件系统</p>
<h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>内容提要</p>
<p>We have designed and implemented the Google File System, a scalable distributed file system for large distributed data-intensive applications. It provides fault tolerance while running on inexpensive commodity hardware, and it delivers high aggregate performance to a large number of clients.</p>
<p>我们设计并实现了Google文件系统，这是一个可扩展的分布式文件系统，适用于大型分布式数据密集型应用。它在廉价的商品硬件上运行的同时提供了容错能力，并为大量的客户机提供了很高的聚合性能。</p>
<p>While sharing many of the same goals as previous distributed file systems, our design has been driven by observations of our application workloads and technological environment, both current and anticipated, that reflect a marked departure from some earlier file system assumptions. This has led us to reexamine traditional choices and explore radically different design points.</p>
<p>虽然与以前的分布式文件系统有许多相同的目标，但我们的设计出发点在于我们的应用工作负载和对技术环境的观察，包括当前的和将来预计会出现的。这些具体情况反映出与早期的一些文件系统设计有明显的偏离。这促使我们重新审视传统的选择，探索完全不同的设计点。</p>
<p>The file system has successfully met our storage needs. It is widely deployed within Google as the storage platform for the generation and processing of data used by our service as well as research and development efforts that require large data sets. The largest cluster to date provides hundreds of terabytes of storage across thousands of disks on over a thousand machines, and it is concurrently accessed by hundreds of clients.</p>
<p>GFS成功地满足了我们的存储需求。它被广泛地部署在谷歌内部，作为存储平台，用于生成和处理我们的服务所使用的数据以及需要大量数据集的研发工作。迄今为止，最大的集群在一千多台机器上的数千块磁盘上并提供了数百兆字节的存储，有数百个客户机同时访问。</p>
<p>In this paper, we present file system interface extensions designed to support distributed applications, discuss many aspects of our design, and report measurements from both micro-benchmarks and real world use.</p>
<p>在本文中，我们提出了旨在支持分布式应用的文件系统接口扩展，讨论了我们设计的许多方面，并报告了从小规模性能测试和现实世界使用中的测量结果。</p>
<h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h2><p>介绍</p>
<p>We have designed and implemented the Google File System (GFS) to meet the rapidly growing demands of Google’s data processing needs. GFS shares many of the same goals as previous distributed file systems such as performance, scalability, reliability, and availability. However, its design has been driven by key observations of our application workloads and technological environment, both current and anticipated, that reflect a marked departure from some earlier file system design assumptions. We have reexamined traditional choices and explored radically different points in the design space.</p>
<p>我们设计并实现了Google文件系统（GFS），以满足Google快速增长的数据处理需求。GFS与以前的分布式文件系统有许多相同的设计目标，如性能、可扩展性、可靠性和可用性。然而，它的设计是由我们对应用工作负载和技术环境的关键观察所驱动的，包括当前和预期的技术环境，反映出与早期的一些文件系统设计有了明显的偏离。我们重新审视了传统的选择，探索了设计空间中不同的设计思路。</p>
<p>First, component failures are the norm rather than the exception. The file system consists of hundreds or even thousands of storage machines built from inexpensive commodity parts and is accessed by a comparable number of client machines. The quantity and quality of the components virtually guarantee that some are not functional at any given time and some will not recover from their current failures. We have seen problems caused by application bugs, operating system bugs, human errors, and the failures of disks, memory, connectors, networking, and power supplies. Therefore, constant monitoring, error detection, fault tolerance, and automatic recovery must be integral to the system.</p>
<p>首先，组件故障是常态，而不是例外。文件系统由数百甚至数千台存储机组成，这些存储机都是由廉价的商用设备组装而成，并被相当数量的客户机同时访问。这些设备的数量和质量无形中决定任何时候都可能有某些设备无法正常工作，有些设备也无法从当前的故障中恢复。我们已经遇到了由应用程序bug、操作系统bug、人为的错误，以及磁盘、内存、连接器、网络、电源的故障等造成的问题。因此，持续的监控、错误检测、容错和自动恢复必须成为该系统的组成部分。</p>
<p>Second, files are huge by traditional standards. Multi-GB files are common. Each file typically contains many application objects such as web documents. When we are regularly working with fast growing data sets of many TBs comprising billions of objects, it is unwieldy to manage billions of approximately KB-sized files even when the file system could support it. As a result, design assumptions and parameters such as I/O operation and block sizes have to be revisited.</p>
<p>第二，我们的文件通常比较大。GB级别文件是很常见的。每个文件通常包含许多应用程序对象，如Web文档等。当我们经常处理由数十亿个对象组成的，TB级别的，快速增长的数据集时，即使文件系统可以支持数十亿个KB大小级别的文件，但要管理起来也是不方便的。因此，设计假设和参数（如I/O操作和块大小）必须重新审视。</p>
<p>Third, most files are mutated by appending new data rather than overwriting existing data. Random writes within a file are practically non-existent. Once written, the files are only read, and often only sequentially. A variety of data share these characteristics. Some may constitute large repositories that data analysis programs scan through. Some may be data streams continuously generated by running applications. Some may be archival data. Some may be intermediate results produced on one machine and processed on another, whether simultaneously or later in time. Given this access pattern on huge files, appending becomes the focus of performance optimization and atomicity guarantees, while caching data blocks in the client loses its appeal.</p>
<p>第三，大多数文件修改是通过追加而不是覆盖来进行的，几乎不存在随机写入的情况。一旦文件被写入，通常就只会被读取，而且往往是顺序读取。大部分数据都有这些特点。有些可能构成了数据分析程序扫描过的大型存储库。有些可能是由运行中的应用程序连续产生的数据流。有些可能是存档数据。有些可能是在一台机器上产生的中间结果，在另一台机器上处理，不管是同时进行还是晚些时候进行。考虑到这种对大型的访问模式，追加性能成为性能优化和原子性保证的重点，而不是客户端中的缓存数据块。</p>
<p>Fourth, co-designing the applications and the file system API benefits the overall system by increasing our flexibility. For example, we have relaxed GFS’s consistency model to vastly simplify the file system without imposing an onerous burden on the applications. We have also introduced an atomic append operation so that multiple clients can append concurrently to a file without extra synchronization between them. These will be discussed in more details later in the paper.</p>
<p>第四，应用程序和文件系统API的协同增加了我们设计的灵活性，对整个系统有好处。例如，我们放宽了GFS的一致性模型的要求，极大地简化了文件系统的一致性模型，而不会给应用带来繁重的负担。我们还引入了原子追加操作，使多个客户端可以同时追加到一个文件，而不需要额外的同步。这些将在本文的后面详细讨论。</p>
<p>Multiple GFS clusters are currently deployed for different purposes. The largest ones have over 1000 storage nodes, over 300 TB of disk storage, and are heavily accessed by hundreds of clients on distinct machines on a continuous basis.</p>
<p>我们目前部署了多个GFS集群，用于不同的需求。最大的有超过1000个存储节点，超过300TB的磁盘存储，并且有上百个客户机连续大量访问。</p>
<h2 id="2-DESIGN-OVERVIEW"><a href="#2-DESIGN-OVERVIEW" class="headerlink" title="2. DESIGN OVERVIEW"></a>2. DESIGN OVERVIEW</h2><p>设计概述</p>
<h3 id="2-1-Assumptions"><a href="#2-1-Assumptions" class="headerlink" title="2.1 Assumptions"></a>2.1 Assumptions</h3><p>预期</p>
<p>In designing a file system for our needs, we have been guided by assumptions that offer both challenges and opportunities. We alluded to some key observations earlier and now lay out our assumptions in more details.</p>
<p>在设计一个符合我们需求的文件系统时，我们一直以各种假设为指导，这些假设既带来了挑战，也带来了机遇。我们在前面提到了一些关键的意见，现在详细介绍一下我们的假设。</p>
<ul>
<li><p>The system is built from many inexpensive commodity components that often fail. It must constantly monitor itself and detect, tolerate, and recover promptly from component failures on a routine basis.</p>
</li>
<li><p>系统是由许多廉价的商品部件组成的，这些部件经常会出现故障。它必须能够监控自己的状态，定期检测、容错以及自动恢复。</p>
</li>
<li><p>The system stores a modest number of large files. We expect a few million files, each typically 100 MB or larger in size. Multi-GB files are the common case and should be managed efficiently. Small files must be supported, but we need not optimize for them.</p>
</li>
<li><p>系统存储了一定数量的大文件。我们预计有几百万个文件，每个文件的大小一般在100MB以上。GB级的文件是常见的情况，应该进行有效的管理。小文件必须支持，但我们不需要对其进行优化。</p>
</li>
<li><p>The workloads primarily consist of two kinds of reads: large streaming reads and small random reads. In large streaming reads, individual operations typically read hundreds of KBs, more commonly 1 MB or more. Successive operations from the same client often read through a contiguous region of a file. A small random read typically reads a few KBs at some arbitrary offset. Performance-conscious applications often batch and sort their small reads to advance steadily through the file rather than go back and forth.</p>
</li>
<li><p>工作负载有两种读取构成：大规模流式读取和小规模随机读取。在大规模流式读取中，一次读取通常会达到数百KB，更常见的是1MB或更多。来自同一客户端的连续操作通常会读取文件的连续区域。一个小规模随机读通常会在一个文件的任意位置读取几个KB。注重性能的应用程序通常会对小读进行批处理和排序，以稳定地读取文件，而不是来回读。</p>
</li>
<li><p>The workloads also have many large, sequential writes that append data to files. Typical operation sizes are similar to those for reads. Once written, files are seldom modified again. Small writes at arbitrary positions in a file are supported but do not have to be efficient.</p>
</li>
<li><p>这些工作负载也有许多大型的、连续的写入操作，将数据追加到文件中。通常的操作大小与读取的操作大小类似。一旦写入，文件很少会被再次修改。支持在文件中任意位置的小规模写入，但不对性能做要求。</p>
</li>
<li><p>The system must efficiently implement well-defined semantics for multiple clients that concurrently append to the same file. Our files are often used as producer-consumer queues or for many-way merging. Hundreds of producers, running one per machine, will concurrently append to a file. Atomicity with minimal syn- chronization overhead is essential. The file may be read later, or a consumer may be reading through the file simultaneously.</p>
</li>
<li><p>系统必须有效地定义好的语义，以便于支持多个客户端并行追加同一个文件。我们的文件经常被用作生产者-消费者队列或多向合并。每台机器上运行的数百个生产者将并发地追加到一个文件。原子性与最小的同步化开销是至关重要的。该文件可能会被随后读取，或者一个消费者可能在追加时同时读取该文件。</p>
</li>
<li><p>High sustained bandwidth is more important than low latency. Most of our target applications place a premium on processing data in bulk at a high rate, while few have stringent response time requirements for an individual read or write.</p>
</li>
<li><p>高持续带宽比低延迟更重要。我们的大多数目标应用都看重的是以高速度批量处理数据，而很少有人对单个读或写的响应时间有严格的要求。</p>
</li>
</ul>
<h3 id="2-2-Interface"><a href="#2-2-Interface" class="headerlink" title="2.2 Interface"></a>2.2 Interface</h3><p>接口</p>
<p>GFS provides a familiar file system interface, though it does not implement a standard API such as POSIX. Files are organized hierarchically in directories and identified by path-names. We support the usual operations to create, delete, open, close, read, and write files.</p>
<p>GFS提供了一个熟悉的文件系统接口，尽管它没有实现像POSIX这样的标准API。文件是按目录分层组织的，并通过路径名来标识。我们支持创建、删除、打开、关闭、读取和写入文件等常规操作。</p>
<p>Moreover, GFS has snapshot and record append operations. Snapshot creates a copy of a file or a directory tree at low cost. Record append allows multiple clients to append data to the same file concurrently while guaranteeing the atomicity of each individual client’s append. It is use- ful for implementing multi-way merge results and producer-consumer queues that many clients can simultaneously append to without additional locking. We have found these types of files to be invaluable in building large distributed applications. Snapshot and record append are discussed further in Sections 3.4 and 3.3 respectively.</p>
<p>此外，GFS还支持快照和记录追加操作。快照可以低成本地创建一个文件或目录树的副本。记录追加允许多个客户端同时追加数据到同一个文件，同时保证每个客户端的追加操作的原子性。它适用于实现多向合并结果和生产者-消费者队列，许多客户端可以同时追加数据，而不需要额外的锁定。我们发现这些类型的文件在构建大型分布式应用中是非常有价值的。快照和记录追加将分别在3.4和3.3节中进一步讨论。</p>
<h3 id="2-3-Architecture"><a href="#2-3-Architecture" class="headerlink" title="2.3 Architecture"></a>2.3 Architecture</h3><p>架构</p>
<p>A GFS cluster consists of a single master and multiple chunkservers and is accessed by multiple clients, as shown in Figure 1. Each of these is typically a commodity Linux machine running a user-level server process. It is easy to run both a chunkserver and a client on the same machine, as long as machine resources permit and the lower reliability caused by running possibly flaky application code is acceptable.</p>
<p>一个GFS集群由一个master和多个chunkserver组成，并同时有多个客户端访问，如图1所示。其中每一个节点通常是一台运行用户级服务器进程的商用Linux机器。在同一台机器上同时运行一个chunkserver和一个客户端是很容易的，只要机器资源允许，而且运行不稳定的应用程序代码所造成的低可靠性是可以接受的。</p>
<p>Files are divided into fixed-size chunks. Each chunk is identified by an immutable and globally unique 64 bit chunk handle assigned by the master at the time of chunk creation. Chunkservers store chunks on local disks as Linux files and read or write chunk data specified by a chunk handle and byte range. For reliability, each chunk is replicated on multiple chunkservers. By default, we store three replicas, though users can designate different replication levels for different regions of the file namespace.</p>
<p>文件被划分成固定大小的块。每个数据块都由master在创建数据块时分配的一个不可更改的、全局唯一的64位数据块句柄来标识。Chunkservers将数据块作为Linux文件存储在本地磁盘上，并通过块句柄和字节范围来读写块数据。为了保证可靠性，每个数据块会被复制到多个chunkservers上。默认情况下，我们存储三个副本，但用户可以为文件命名空间的不同区域指定不同的复制级别。</p>
<p><img src="https://images.haishenming.xyz/blog/20200514101848.png" alt="图1"></p>
<p>he master maintains all file system metadata. This includes the namespace, access control information, the maping from files to chunks, and the current locations of chunks. It also controls system-wide activities such as chunk lease management, garbage collection of orphaned chunks, and chunk migration between chunkservers. The master periodically communicates with each chunkserver in HeartBeat messages to give it instructions and collect its state.</p>
<p>master维护所有文件系统的元数据。这包括命名空间、访问控制信息、从文件到数据块的映射，以及数据块的当前位置。它还控制着整个系统的活动，比如说数据块租约管理，垃圾收集，以及数据块在服务器之间的迁移。master定期通过心跳消息与每个chunkserver进行通信，向其发出指令并收集状态。</p>
<p>GFS client code linked into each application implements the file system API and communicates with the master and chunkservers to read or write data on behalf of the application. Clients interact with the master for metadata operations, but all data-bearing communication goes directly to the chunkservers. We do not provide the POSIX API and therefore need not hook into the Linux vnode layer.</p>
<p>GFS库链接到每个应用程序中，它实现了文件系统API，并与msater和chunkservers通信，帮组应用程序读取或写入数据。客户端与master进行元数据操作的交互，但所有的数据承载通信都直接到chunkservers。我们不提供POSIX API，因此不需要连接到Linux vnode层。</p>
<p>Neither the client nor the chunkserver caches file data. Client caches offer little benefit because most applications stream through huge files or have working sets too large to be cached. Not having them simplifies the client and the overall system by eliminating cache coherence issues. (Clients do cache metadata, however.) Chunkservers need not cache file data because chunks are stored as local files and so Linux’s buffer cache already keeps frequently accessed data in memory.</p>
<p>客户端和chunkserver都不缓存文件数据。客户端缓存的好处不大，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。，从而简化了客户端和整个系统。(不过，客户端会缓存元数据。)chunkservers不需要缓存文件数据，因为数据块是作为本地文件存储的，所以Linux的缓冲区缓存已经将频繁访问的数据保存在内存中。</p>
<h3 id="2-4-Single-Master"><a href="#2-4-Single-Master" class="headerlink" title="2.4 Single Master"></a>2.4 Single Master</h3><p>单节点master</p>
<p>Having a single master vastly simplifies our design and enables the master to make sophisticated chunk placement and replication decisions using global knowledge. However, we must minimize its involvement in reads and writes so that it does not become a bottleneck. Clients never read and write file data through the master. Instead, a client asks the master which chunkservers it should contact. It caches this information for a limited time and interacts with the chunkservers directly for many subsequent operations.</p>
<p>拥有一个单节点的master大大简化了我们的设计，并使master能够利用全局知识做出复杂的区块放置和复制决策。但是，我们必须尽量减少它在读和写中的参与，以免成为瓶颈。客户端从不通过master读写文件数据。相反，客户端会询问master应该联系哪些chunkserver。它在有限的时间内缓存这些信息，并在随后的许多操作中直接与chunkserver进行交互。</p>
<p>Let us explain the interactions for a simple read with reference to Figure 1. First, using the fixed chunk size, the client translates the file name and byte offset specified by the application into a chunk index within the file. Then, it sends the master a request containing the file name and chunk index. The master replies with the corresponding chunk handle and locations of the replicas. The client caches this information using the file name and chunk index as the key.</p>
<p>让我们参照图1来解释一下简单的读取流程。首先，使用固定的chunk大小，客户端将应用程序指定的文件名和字节偏移量翻译成文件内的chunk索引。然后，它向master发送一个包含文件名和块索引的请求。master会回复相应的chunk句柄和副本的位置。客户端使用文件名和chunk索引作为关键来缓存这些信息。</p>
<p>The client then sends a request to one of the replicas, most likely the closest one. The request specifies the chunk handle and a byte range within that chunk. Further reads of the same chunk require no more client-master interaction until the cached information expires or the file is reopened. In fact, the client typically asks for multiple chunks in the same request and the master can also include the information for chunks immediately following those requested. This extra information sidesteps several future client-master interactions at practically no extra cost.</p>
<p>然后客户端向其中一个副本发送一个请求，很可能是最接近的一个副本。该请求指定了数据块的句柄和该数据块中的字节范围。在缓存信息过期或文件被重新打开之前，对同一数据块的进一步读取不需要更多的客户端和master交互。事实上，客户端通常会在同一请求中请求多个块，master也可以包含紧随请求的块之后的信息。这些额外的信息避免了未来客户机与主机的交互，几乎不需要额外的成本。</p>
<h3 id="2-5-Chunk-Size"><a href="#2-5-Chunk-Size" class="headerlink" title="2.5 Chunk Size"></a>2.5 Chunk Size</h3><p>2.5 Chunk大小</p>
<p>Chunk size is one of the key design parameters. We have chosen 64 MB, which is much larger than typical file system block sizes. Each chunk replica is stored as a plain Linux file on a chunkserver and is extended only as needed. Lazy space allocation avoids wasting space due to internal fragmentation, perhaps the greatest objection against such a large chunk size.</p>
<p>Chunk大小是设计的关键参数之一。我们选择了64 MB，这比典型的文件系统块大小要大得多。每个chunk副本都作为一个普通的Linux文件存储在chunkserver上，并且只在需要的时候进行扩展。空间的慢分配避免了由于内部碎片化造成的空间浪费，这或许是对如此大的chunk大小的最具有争议的一点。</p>
<p>A large chunk size offers several important advantages. First, it reduces clients’ need to interact with the master because reads and writes on the same chunk require only one initial request to the master for chunk location information. The reduction is especially significant for our workloads because applications mostly read and write large files sequentially. Even for small random reads, the client can comfortably cache all the chunk location information for a multi-TB working set. Second, since on a large chunk, a client is more likely to perform many operations on a given chunk, it can reduce network overhead by keeping a persistent TCP connection to the chunkserver over an extended period of time. Third, it reduces the size of the metadata stored on the master. This allows us to keep the metadata in memory, which in turn brings other advantages that we will discuss in Section 2.6.1.</p>
<p>较大的chunk大小提供了几个重要的优势。首先，它减少了客户机与master的交互需求，因为在同一块上的读和写只需要向master发送一次初始请求，就可以获得块位置信息。这种简化对于我们的工作负载来说尤其重要，因为应用程序大多是按顺序读写大文件。即使是较小的随机读取，客户端也可以很容易地缓存数TB的工作集的所有数据块位置信息。第二，由于在一个较大的chunk上，客户端更有可能在一个给定的chunk上执行许多操作，因此可以通过长时间保持与chunkserver的持久TCP连接来减少网络开销。第三，它减少了存储在主站上的元数据的大小。这使得我们可以将元数据保存在内存中，这反过来又带来了我们将在2.6.1节中讨论的其他优点。</p>
<p>On the other hand, a large chunk size, even with lazy space allocation, has its disadvantages. A small file consists of a small number of chunks, perhaps just one. The chunkservers storing those chunks may become hot spots if many clients are accessing the same file. In practice, hot spots have not been a major issue because our applications mostly read large multi-chunk files sequentially.</p>
<p>另一方面，大块chunk的文件，即使是采用慢分配空间，也有其缺点。一个小文件由较少的chunks组成，甚至只有一个。如果很多客户端访问同一个文件，存储这些chunkservers可能会成为热点。在实际应用中，热点问题并不是一个大问题，因为我们的应用大多是按顺序读取大的多块文件。</p>
<p>However, hot spots did develop when GFS was first used by a batch-queue system: an executable was written to GFS as a single-chunk file and then started on hundreds of machines at the same time. The few chunkservers storing this executable were overloaded by hundreds of simultaneous re- quests. We fixed this problem by storing such executables with a higher replication factor and by making the batchqueue system stagger application start times. A potential long-term solution is to allow clients to read data from other clients in such situations.</p>
<p>然而，当GFS第一次被批处理队列系统使用时，确实出现了一些热点：一个可执行文件被写成单个chunk文件写入GFS，然后在数百台机器上同时启动。存储这个可执行文件的少数chunkservers被上百个同时重启的请求超载了。我们通过使用更高的复制系数存储这类可执行文件，并使批处理队列系统错开应用程序的启动时间来修复这个问题。一个潜在的长期解决方案是允许客户端在这种情况下从其他客户端读取数据。</p>
<h3 id="2-6-Metadata"><a href="#2-6-Metadata" class="headerlink" title="2.6 Metadata"></a>2.6 Metadata</h3><p>2.6 元数据</p>
<p>The master stores three major types of metadata: the file and chunk namespaces, the mapping from files to chunks, and the locations of each chunk’s replicas. All metadata is kept in the master’s memory. The first two types (namespaces and file-to-chunk mapping) are also kept persistent by logging mutations to an operation log stored on the master’s local disk and replicated on remote machines. Using a log allows us to update the master state simply, reliably, and without risking inconsistencies in the event of a master crash. The master does not store chunk location information persistently. Instead, it asks each chunkserver about its chunks at master startup and whenever a chunkserver joins the cluster.</p>
<p>msater主要存储三种类型的元数据：文件和块的命名空间、从文件到块的映射，以及每个块的复制位置。所有的元数据都保存在master的内存中。前两种类型（命名空间和文件到块之间的映射）也是通过记录变更到存储在主站本地磁盘上的操作日志并复制到远程机器上的操作日志来保持持久性。通过变更日志日志，我们可以简单、可靠地更新msater状态，并且确保master崩溃时不会出现不一致的风险。master不会持久地存储chunk位置信息。相反，在master启动时和每当一个chunkserver加入集群时，都会询问每个chunkserver关于它的块的信息。</p>
<h4 id="2-6-1-In-Memory-Data-Structures"><a href="#2-6-1-In-Memory-Data-Structures" class="headerlink" title="2.6.1 In-Memory Data Structures"></a>2.6.1 In-Memory Data Structures</h4><p>2.6.1 内存数据结构</p>
<p>Since metadata is stored in memory, master operations are fast. Furthermore, it is easy and efficient for the master to periodically scan through its entire state in the background. This periodic scanning is used to implement chunk garbage collection, re-replication in the presence of chunkserver failures, and chunk migration to balance load and disk space usage across chunkservers. Sections 4.3 and 4.4 will discuss these activities further.</p>
<p>由于元数据存储在内存中，所以master操作速度很快。此外，master在后台周期性地扫描整个状态是很简单和高效的。这种周期性的扫描被用来实现chunkserver的垃圾回收，chunkserver出现故障时的重复制，以及chunkserver之间的负载和磁盘空间使用平衡的块迁移。第4.3和4.4节将进一步讨论这些活动。</p>
<p>One potential concern for this memory-only approach is that the number of chunks and hence the capacity of the whole system is limited by how much memory the master has. This is not a serious limitation in practice. The master maintains less than 64 bytes of metadata for each 64 MB chunk. Most chunks are full because most files contain many chunks, only the last of which may be partially filled. Similarly, the file namespace data typically requires less then 64 bytes per file because it stores file names compactly using prefix compression.</p>
<p>这种仅使用内存的方法的一个潜在的问题是，master的内存大小会限制了整个系统的数据块的数量，从而限制了整个系统的容量。这在实际应用中并不是一个严重的问题。每个64MB的数据块，master只维护不到64字节的元数据。大多数块是满的，因为大多数文件包含许多块，只有最后一个块可能被部分填满。同样的，文件命名空间数据通常每个文件所需的元数据也少于64字节，因为它使用前缀压缩方式紧凑地存储文件名。</p>
<p>If necessary to support even larger file systems, the cost of adding extra memory to the master is a small price to pay for the simplicity, reliability, performance, and flexibility we gain by storing the metadata in memory.</p>
<p>如果有必要支持更大的文件系统，在master中增加额外的内存相对于我们使用内存所带来的的灵活性和便捷性等优点来说，所付出的代价是很小的。</p>
<h4 id="2-6-2-Chunk-Locations"><a href="#2-6-2-Chunk-Locations" class="headerlink" title="2.6.2 Chunk Locations"></a>2.6.2 Chunk Locations</h4><p>2.6.2 块位置</p>
<p>The master does not keep a persistent record of which chunkservers have a replica of a given chunk. It simply polls chunkservers for that information at startup. The master can keep itself up-to-date thereafter because it controls all chunk placement and monitors chunkserver status with regular HeartBeat messages.</p>
<p>master不会持久的保存记录，记录哪些chunkservers有一个给定的块的副本。它只是在启动时对chunkservers进行轮询，以获取这些信息。主站可以在此后保持最新的状态，因为它控制着所有的chunkservers，并通过定期的心跳消息监控chunkserver的状态。</p>
<p>We initially attempted to keep chunk location information persistently at the master, but we decided that it was much simpler to request the data from chunkservers at startup, and periodically thereafter. This eliminated the problem of keeping the master and chunkservers in sync as chunkservers join and leave the cluster, change names, fail, restart, and so on. In a cluster with hundreds of servers, these events happen all too often.</p>
<p>我们最初试图在主站中持续保持chunkservers的位置信息，但我们决定在启动时从chunkservers那里请求数据，并在启动后定期请求。这样一来，当chunkservers加入和离开集群、更改名称、失败、重启等情况下，主服务器和chunkservers保持同步的问题就迎刃而解了。在一个有数百台服务器的集群中，这些事件经常发生。</p>
<p>Another way to understand this design decision is to realize that a chunkserver has the final word over what chunks it does or does not have on its own disks. There is no point in trying to maintain a consistent view of this information on the master because errors on a chunkserver may cause chunks to vanish spontaneously (e.g., a disk may go bad and be disabled) or an operator may rename a chunkserver.</p>
<p>理解这个设计决定的另一个方法是，要知道chunkserver对自己的磁盘上有或没有的chunks有最终决定权。试图在master上保持这些信息的一致性是没有意义的，因为chunkserver上的错误可能会导致chunks自动消失（例如，磁盘可能会坏掉并被禁用），或者操作者可能会重命名chunkserver。</p>
<h4 id="2-6-3-Operation-Log"><a href="#2-6-3-Operation-Log" class="headerlink" title="2.6.3 Operation Log"></a>2.6.3 Operation Log</h4><p>2.6.3 操作日志</p>
<p>The operation log contains a historical record of critical metadata changes. It is central to GFS. Not only is it the only persistent record of metadata, but it also serves as a logical time line that defines the order of concurrent operations. Files and chunks, as well as their versions (see Section 4.5), are all uniquely and eternally identified by the logical times at which they were created.</p>
<p>操作日志包含了关键元数据变化的历史记录。它是GFS的核心。它不仅是元数据的唯一持久记录，而且也是定义了并发操作顺序的逻辑时间线。文件和块，以及它们的版本（见第4.5节），都是由它们创建时的逻辑时间来唯一，永恒地识别。</p>
<p>Since the operation log is critical, we must store it reliably and not make changes visible to clients until metadata changes are made persistent. Otherwise, we effectively lose the whole file system or recent client operations even if the chunks themselves survive. Therefore, we replicate it on multiple remote machines and respond to a client operation only after flushing the corresponding log record to disk both locally and remotely. The master batches several log records together before flushing thereby reducing the impact of flushing and replication on overall system throughput.</p>
<p>由于操作日志非常关键，我们必须可靠地存储它，并且在元数据变化被持久化之前，不能让客户端看到变化。否则，即使块本身没有出现问题，我们也将丢失整个文件系统或最近的客户端操作。因此，我们将其复制到多个远程机器上，只有在本地和远程都将相应的日志记录刷新到磁盘后，才会对客户端操作做出响应。在写入之前，master会将多条日志记录合并在一起，从而减少写入和复制对整个系统吞吐量的影响。</p>
<p>The master recovers its file system state by replaying the operation log. To minimize startup time, we must keep the log small. The master checkpoints its state whenever the log grows beyond a certain size so that it can recover by loading the latest checkpoint from local disk and replaying only the limited number of log records after that. The checkpoint is in a compact B-tree like form that can be directly mapped into memory and used for namespace lookup without extra parsing. This further speeds up recovery and improves availability.</p>
<p>master通过回放操作日志来恢复其文件系统状态。为了尽量减少启动时间，我们必须保持日志的大小。每当日志增长到超过一定大小时，master就会对其状态进行checkpoint，这样，它就可以通过从本地磁盘加载最新的checkpoint来恢复，之后只回放有限的日志记录。该检查点采用了类似于B树的紧凑形式，可以直接映射到内存中，无需额外的解析就可以用于命名空间查找。这进一步加快了恢复速度，提高了可用性。</p>
<p>Because building a checkpoint can take a while, the master’s internal state is structured in such a way that a new checkpoint can be created without delaying incoming mutations. The master switches to a new log file and creates the new checkpoint in a separate thread. The new checkpoint includes all mutations before the switch. It can be created in a minute or so for a cluster with a few million files. When completed, it is written to disk both locally and remotely.</p>
<p>因为建立一个检checkpoint可能需要一段时间，所以master内部状态的结构是这样的，这样就可以在不延迟传入突变的情况下创建一个新的checkpoint。master会切换到一个新的日志文件，并在一个单独的线程中创建新的checkpoint。新的checkpoint包含了切换前的所有修改。对于一个有几百万个文件的集群，它可以在一分钟左右的时间内创建。完成后，它将被写到磁盘上，包括本地和远程。</p>
<p>Recovery needs only the latest complete checkpoint and subsequent log files. Older checkpoints and log files can be freely deleted, though we keep a few around to guard against catastrophes. A failure during checkpointing does not affect correctness because the recovery code detects and skips incomplete checkpoints.</p>
<p>恢复只需要最新的完整checkpoint和后续的日志文件。较旧的checkpoint和日志文件可以自由删除，不过我们会保留一些以防止灾难发生。在checkpoint期间发生的故障不会影响正确性，因为恢复代码会检测并跳过不完整的检查点。</p>
<hr>
<p> 未完待续！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MIT/" rel="tag"># MIT</a>
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a>
              <a href="/tags/%E8%AF%91%E6%96%87/" rel="tag"># 译文</a>
              <a href="/tags/%E8%AE%BA%E6%96%87/" rel="tag"># 论文</a>
              <a href="/tags/GFS/" rel="tag"># GFS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/12/SQL-HackerRank-Weather-Observation-Station-4/" rel="prev" title="[SQL]HackerRank: Weather Observation Station 4">
      <i class="fa fa-chevron-left"></i> [SQL]HackerRank: Weather Observation Station 4
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%B3%E4%BA%8EHTTP%E7%9A%84%E4%B8%80%E5%88%87/" rel="next" title="[计算机网络2]我所知道的关于HTTP的一切">
      [计算机网络2]我所知道的关于HTTP的一切 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%AF%BB"><span class="nav-number">1.</span> <span class="nav-text">导读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%9A%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">大型分布式文件系统难在哪里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GFS%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">GFS做了什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Google-File-System"><span class="nav-number"></span> <span class="nav-text">The Google File System</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ABSTRACT"><span class="nav-number">1.</span> <span class="nav-text">ABSTRACT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-INTRODUCTION"><span class="nav-number">2.</span> <span class="nav-text">1. INTRODUCTION</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-DESIGN-OVERVIEW"><span class="nav-number">3.</span> <span class="nav-text">2. DESIGN OVERVIEW</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Assumptions"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 Assumptions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Interface"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Architecture"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 Architecture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Single-Master"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 Single Master</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Chunk-Size"><span class="nav-number">3.5.</span> <span class="nav-text">2.5 Chunk Size</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-Metadata"><span class="nav-number">3.6.</span> <span class="nav-text">2.6 Metadata</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-In-Memory-Data-Structures"><span class="nav-number">3.6.1.</span> <span class="nav-text">2.6.1 In-Memory Data Structures</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-Chunk-Locations"><span class="nav-number">3.6.2.</span> <span class="nav-text">2.6.2 Chunk Locations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-Operation-Log"><span class="nav-number">3.6.3.</span> <span class="nav-text">2.6.3 Operation Log</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xavier</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xavier</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
