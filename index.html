<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xavierx.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Xavier&#39;s Blog">
<meta property="og:url" content="https://xavierx.cn/index.html">
<meta property="og:site_name" content="Xavier&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xavier">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xavierx.cn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Xavier's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Xavier's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2021/08/02/%E4%B8%80%E6%AC%A1%E9%AB%98%E5%B9%B6%E5%8F%91golang%20%60too%20mange%20open%20files%60%E6%8A%A5%E9%94%99debug%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/02/%E4%B8%80%E6%AC%A1%E9%AB%98%E5%B9%B6%E5%8F%91golang%20%60too%20mange%20open%20files%60%E6%8A%A5%E9%94%99debug%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">一次高并发golang [too mange open files] 报错debug过程记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-02 22:12:27" itemprop="dateCreated datePublished" datetime="2021-08-02T22:12:27+08:00">2021-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-03 14:49:23" itemprop="dateModified" datetime="2021-08-03T14:49:23+08:00">2021-08-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%94%99%E9%A2%98%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">错题集</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近写了一个需要大量http请求的golang程序，在高并发的情况下，出现大量报错<code>too mange open files</code>（以下简称该错误），下面记录一下debug的过程、解决方法以及遗留的问题。</p>
<h2 id="查看进程打开的文件句柄"><a href="#查看进程打开的文件句柄" class="headerlink" title="查看进程打开的文件句柄"></a>查看进程打开的文件句柄</h2><p>该错误出现的原因，一般是由于linux系统下，一个进程打开了过多的文件而被系统所限制了，那么首先的思路便是查看当前程序的经常的的限制以及共打开了多少文件以及打开了哪些文件，假如当前golang程序的进程号是22761</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 查看限制</span></span><br><span class="line">cat /proc/22761/limits </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看大小</span></span><br><span class="line">lsof -p 22761 | wc -l  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看有哪些</span></span><br><span class="line">lsof -p 22761 &gt; openfile.log</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，当前进程所能够打开的文件数量被限制在了1024，并且目前已经超出了这个限制，打开的大量文件是tcp连接，处在<code>ESTABLISHED</code>。</p>
<h2 id="http-transport配置"><a href="#http-transport配置" class="headerlink" title="http transport配置"></a>http transport配置</h2><p>在确定了是因为大量并发导致了创建大量的tcp连接之后，在确认了<code>response.Body</code>是及时关闭，并且设置了超时限制之后，于是考虑是否从<code>http.Client</code>的设置入手，限制一下连接数量，于是有了以下设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">httpClient :&#x3D; &amp;http.Client&#123;Transport: &amp;http.Transport&#123;</span><br><span class="line">	MaxIdleConns:        512,</span><br><span class="line">	MaxIdleConnsPerHost: 2,</span><br><span class="line">	DisableKeepAlives:   false,</span><br><span class="line">	MaxConnsPerHost:     512,</span><br><span class="line">	IdleConnTimeout:     10 * time.*Second*,</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>然而当时并没有生效，<del>后来复盘发现是因为我只在每个协程中复用了同一个client，而没有全局复用，因此还是会超出数量。</del> 后来发现是因为，没有给<code>mongo-go-drive</code>设置限制，而并发量大导致client不停的创建新连接所致。</p>
<h2 id="修改最大文件句柄限制"><a href="#修改最大文件句柄限制" class="headerlink" title="修改最大文件句柄限制"></a>修改最大文件句柄限制</h2><p>由于上述方案当时没有生效，不得已只能修改最大文件句柄的限制了，修改如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/security/limits.conf</span></span><br><span class="line">root hard nofile 65535</span><br><span class="line">root soft nofile 65535</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看有没有生效</span></span><br><span class="line"><span class="built_in">ulimit</span> -n</span><br></pre></td></tr></table></figure>
<p>然而还是没有生效，在重新查看进程的文件句柄限制之后，发现依然是1024</p>
<h2 id="supervisor-的问题"><a href="#supervisor-的问题" class="headerlink" title="supervisor 的问题"></a>supervisor 的问题</h2><p>后来经查询，发现可能是因为使用了supervisor作为守护进程，而supervisor在这一块做了手脚，导致被supervisor守护的进程没有生效，修改supervisor的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/supervisor.conf</span></span><br><span class="line">minfds=65536 <span class="comment"># 限制了supervisor守护的进程的文件句柄限制</span></span><br></pre></td></tr></table></figure>

<p>修改后supervisor需要杀掉进程重启，使用<code>supervisorctl reload</code>可能会无效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/12/07/go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">译文-go内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-07 20:49:37" itemprop="dateCreated datePublished" datetime="2020-12-07T20:49:37+08:00">2020-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://golang.org/ref/mem">The Go Memory Model - The Go Programming Language</a></p>
<h1 id="The-Go-Memory-Model"><a href="#The-Go-Memory-Model" class="headerlink" title="The Go Memory Model"></a>The Go Memory Model</h1><h1 id="Go-内存模型"><a href="#Go-内存模型" class="headerlink" title="Go 内存模型"></a>Go 内存模型</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>The Go memory model specifies the conditions under which reads of a variable in one goroutine can be guaranteed to observe values produced by writes to the same variable in a different goroutine.</p>
<p>Go内存模型规定了在什么条件下，可以保证对一个goroutine中在读操作时可以观察到另一个goroutine对同一变量的写操作的值。</p>
<h2 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h2><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.</p>
<p>To serialize access, protect the data with channel operations or other synchronization primitives such as those in the sync and sync/atomic packages.</p>
<p>If you must read the rest of this document to understand the behavior of your program, you are being too clever.</p>
<p>Don’t be clever.</p>
<p>修改被多个goroutine同时访问的数据的时必须有序。</p>
<p>要有序访问，请使用channel操作或其他同步元语（如sync和sync/atomic）来保护数据。</p>
<p>请务必通过阅读该文章来理解你程序的行为。</p>
<p>不要自作聪明。</p>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><h2 id="Happens-Before-1"><a href="#Happens-Before-1" class="headerlink" title="Happens Before"></a>Happens Before</h2><p>Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program. That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification. Because of this reordering, the execution order observed by one goroutine may differ from the order perceived by another. For example, if one goroutine executes a = 1; b = 2;, another might observe the updated value of b before the updated value of a.</p>
<p>在一个goroutine内，读写必须按照程序指定的顺序执行。也就是说，编译器和处理器只有在重排时不会改变语言规范所定义的goroutine内的行为时，才可以对单个goroutine内执行的读和写进行重排。由于这种重排，一个goroutine观察到的执行顺序可能与另一个goroutine感知到的顺序不同。例如，如果一个goroutine执行a=1；b=2；，另一个goroutine可能会在a的更新值之前观察到b的更新值。</p>
<p>To specify the requirements of reads and writes, we define <em>happens before</em>, a partial order on the execution of memory operations in a Go program. If event e1 happens before event e2, then we say that e2 happens after e1. Also, if e1 does not happen before e2 and does not happen after e2, then we say that e1 and e2 happen concurrently.</p>
<p>为了明确读写的要求，我们定义了<em>happens before</em>，即Go程序中内存操作执行的局部顺序。如果事件e1发生在事件e2之前，那么我们说<em>e2 happens after e1</em>。另外，如果e1没有发生在e2之前，也没有发生在e2之后，那么我们说<em>e1 and e2 happen concurrently</em>。</p>
<p><em>Within a single goroutine, the happens-before order is the order expressed by the program.</em></p>
<p><em>在单个goroutine中，happens before的顺序是程序所表达的顺序。</em></p>
<p>A read <em>r</em> of a variable v is <em>allowed</em> to observe a write <em>w</em> to v if both of the following hold:<br>    1. <em>r</em> does not happen before <em>w</em>.<br>    2. There is no other write <em>w’</em> to v that happens after <em>w</em> but before <em>r</em>.</p>
<p>一个变量v的读<em>r</em>如果以下两个条件都成立，则<em>允许</em>观察v的写<em>w</em>。<br>    1. <em>r</em>不发生在<em>w</em>之前。<br>    2. 在<em>w</em>之后而在<em>r</em>之前没有其他对v的写*w’*。</p>
<p>To guarantee that a read <em>r</em> of a variable v observes a particular write <em>w</em> to v, ensure that <em>w</em> is the only write <em>r</em> is allowed to observe. That is, <em>r</em> is <em>guaranteed</em> to observe <em>w</em> if both of the following hold:<br>    1. <em>w</em> happens before <em>r</em>.<br>    2. Any other write to the shared variable v either happens before <em>w</em> or after <em>r</em>.</p>
<p>为了保证变量v的读<em>r</em>观察到对v的特定写<em>w</em>，保证<em>w</em>是唯一允许<em>r</em>观察的写。也就是说，如果以下两个条件都成立，则<em>r</em>被保证观察到<em>w</em>。<br>    1. <em>w</em>发生在<em>r</em>之前。<br>    2. 任何其他对共享变量v的写要么发生在<em>w</em>之前，要么发生在<em>r</em>之后。</p>
<p>This pair of conditions is stronger than the first pair; it requires that there are no other writes happening concurrently with <em>w</em> or <em>r</em>.</p>
<p>这对条件比第一对条件更强，它要求没有其他操作与w或r同时发生。</p>
<p>Within a single goroutine, there is no concurrency, so the two definitions are equivalent: a read <em>r</em> observes the value written by the most recent write <em>w</em> to v. When multiple goroutines access a shared variable v, they must use synchronization events to establish <em>happens-before</em> conditions that ensure reads observe the desired writes.</p>
<p>在单个goroutine内，不存在并发性，所以这两个定义是等价的：读r观察最近一次向v写入的w所写的值。当多个goroutine访问一个共享变量v时，它们必须使用同步事件来建立<em>happens-before</em>条件，以确保读观察到所需的写。</p>
<p>The initialization of variable v with the zero value for v’s type behaves as a write in the memory model.</p>
<p>变量v的初始化，v的类型为零值，在内存模型中表现为写。</p>
<p>Reads and writes of values larger than a single machine word behave as multiple machine-word-sized operations in an unspecified order.</p>
<p>对大于一个机器字的值的读写，将以一个未指定的顺序进行多个机器字大小的操作。</p>
<h2 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h2><h2 id="同步化"><a href="#同步化" class="headerlink" title="同步化"></a>同步化</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Program initialization runs in a single goroutine, but that goroutine may create other goroutines, which run concurrently.</p>
<p>程序初始化在一个goroutine中运行，但该goroutine可以创建其他goroutine，这些goroutine同时运行。</p>
<p><em>If a package<strong>p</strong>imports package<strong>q</strong>, the completion of<strong>q</strong>’s<strong>init</strong>functions happens before the start of any of<strong>p</strong>’s.</em></p>
<p>如果一个包p导入了包q，那么q的init函数的完成就发生在p的任何一个函数开始之前。</p>
<p><em>The start of the function<strong>main.main</strong>happens after all<strong>init</strong>functions have finished.</em></p>
<p>函数main.main的启动发生在所有init函数完成之后。</p>
<h3 id="Goroutine-creation"><a href="#Goroutine-creation" class="headerlink" title="Goroutine creation"></a>Goroutine creation</h3><h3 id="Goroutine的创建"><a href="#Goroutine的创建" class="headerlink" title="Goroutine的创建"></a>Goroutine的创建</h3><p><em>The<strong>go</strong>statement that starts a new goroutine happens before the goroutine’s execution begins.</em></p>
<p>启动一个新的goroutine的go语句发生在goroutine的执行开始之前。</p>
<p>For example, in this program:</p>
<p>例如，在这个程序中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>calling hello will print “hello, world” at some point in the future (perhaps after hello has returned).</p>
<p>调用hello将在未来的某个时刻打印 “hello，world”（也许在hello返回后）。</p>
<h3 id="Goroutine-destruction"><a href="#Goroutine-destruction" class="headerlink" title="Goroutine destruction"></a>Goroutine destruction</h3><h3 id="Goroutine的销毁"><a href="#Goroutine的销毁" class="headerlink" title="Goroutine的销毁"></a>Goroutine的销毁</h3><p>The exit of a goroutine is not guaranteed to happen before any event in the program. For example, in this program:</p>
<p>goroutine的退出不保证在程序中的任何事件之前发生。例如，在这个程序中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a = <span class="string">&quot;hello&quot;</span> &#125;()</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>the assignment to a is not followed by any synchronization event, so it is not guaranteed to be observed by any other goroutine. In fact, an aggressive compiler might delete the entire go statement.</p>
<p>a的赋值之后没有任何同步事件，所以不能保证它被其他goroutine观察到。事实上，一个激进的编译器可能会删除整个go语句。</p>
<p>If the effects of a goroutine must be observed by another goroutine, use a synchronization mechanism such as a lock or channel communication to establish a relative ordering.</p>
<p>如果一个goroutine的效果必须由另一个goroutine观察，则使用锁或通道通信等同步机制来建立相对的排序。</p>
<h3 id="Channel-communication"><a href="#Channel-communication" class="headerlink" title="Channel communication"></a>Channel communication</h3><h3 id="使用channel通信"><a href="#使用channel通信" class="headerlink" title="使用channel通信"></a>使用channel通信</h3><p>Channel communication is the main method of synchronization between goroutines. Each send on a particular channel is matched to a corresponding receive from that channel, usually in a different goroutine.</p>
<p>channel是goroutine之间同步的主要方法。在某一特定channel上的每一次发送都与来自该channel的相应接收相匹配，通常在不同的goroutine中进行。</p>
<p><em>A send on a channel happens before the corresponding receive from that channel completes.</em></p>
<p>在一个通道上的发送发生在该通道相应的接收完成之前。</p>
<p>This program:</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	&lt;-c</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>is guaranteed to print “hello, world”. The write to a happens before the send on c, which happens before the corresponding receive on c completes, which happens before the print.</p>
<p>该程序是保证打印 “hello, world “的。对a的写入发生在c上的send之前，send发生在c上相应的receive完成之前，receive发生在print之前。</p>
<p><em>The closing of a channel happens before a receive that returns a zero value because the channel is closed.</em></p>
<p>channel的关闭发生在返回零值的接收之前，因为channel已经关闭。</p>
<p>In the previous example, replacing c &lt;- 0 with close(c) yields a program with the same guaranteed behavior.</p>
<p>在前面的例子中，用close(c)代替c &lt;- 0，可以得到一个具有相同保证行为的程序。</p>
<p><em>A receive from an unbuffered channel happens before the send on that channel completes.</em></p>
<p>从一个非缓冲channel的接收发生在该channel的发送完成之前。</p>
<p>This program (as above, but with the send and receive statements swapped and using an unbuffered channel):</p>
<p>这个程序(和上面一样，但发送和接收语句互换，并使用一个非缓冲channel)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	c &lt;- <span class="number">0</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>is also guaranteed to print “hello, world”. The write to a happens before the receive on c, which happens before the corresponding send on c completes, which happens before the print.</p>
<p>也保证打印 “hello, world”。写入a的过程发生在receive c之前，而receive发生在c上相应的send完成之前，而send完成在print之前。</p>
<p>If the channel were buffered (e.g., c = make(chan int, 1)) then the program would not be guaranteed to print “hello, world”. (It might print the empty string, crash, or do something else.)</p>
<p>如果是带缓冲的channel（例如，c = make(chan int, 1)），那么程序就不能保证打印 “hello, world”。(它可能会打印空字符串，崩溃，或者做其他事情。)</p>
<p><em>The kth receive on a channel with capacity C happens before the k+Cth send from that channel completes.</em></p>
<p>在容量为C的channel上的第k次接收发生在该信道的第k+C次发送完成之前。</p>
<p>This rule generalizes the previous rule to buffered channels. It allows a counting semaphore to be modeled by a buffered channel: the number of items in the channel corresponds to the number of active uses, the capacity of the channel corresponds to the maximum number of simultaneous uses, sending an item acquires the semaphore, and receiving an item releases the semaphore. This is a common idiom for limiting concurrency.</p>
<p>这条规则将前一条规则概括为缓冲channel。它允许用缓冲channel来模拟计数标记：channel中的项数对应于有效使用的次数，通道的容量对应于最大的同时使用次数，发送一个项获得标记，接收一个项释放标记。这是限制并发量的常用写法。</p>
<p>This program starts a goroutine for every entry in the work list, but the goroutines coordinate using the limit channel to ensure that at most three are running work functions at a time.</p>
<p>该程序为工作列表中的每一个条目启动一个goroutine，但goroutine使用刚刚好容量channel进行协调，以保证一次最多运行三个工作函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">			limit &lt;- <span class="number">1</span></span><br><span class="line">			w()</span><br><span class="line">			&lt;-limit</span><br><span class="line">		&#125;(w)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><h3 id="Locks-1"><a href="#Locks-1" class="headerlink" title="Locks"></a>Locks</h3><p>The sync package implements two lock data types, sync.Mutex and sync.RWMutex.</p>
<p>sync包实现了两种锁数据类型，sync.Mutex和sync.RWMutex。</p>
<p><em>For any<strong>sync.Mutex</strong>or<strong>sync.RWMutex</strong>variable<strong>l</strong>and n &lt; m, call n of<strong>l.Unlock()**happens before call m of</strong>l.Lock()**returns.</em></p>
<p>对于任何sync.Mutex或sync.RWMutex变量l且n&lt;m，l.Unlock()的调用n发生在l.Lock()的调用m返回之前。</p>
<p>This program:<br>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>is guaranteed to print “hello, world”. The first call to l.Unlock() (in f) happens before the second call to l.Lock() (in main) returns, which happens before the print.</p>
<p>是保证打印 “hello, world “的。第一次调用l.Unlock()(在f中)发生在第二次调用l.Lock()(在main中)返回之前，而第二次调用发生在打印之前。</p>
<p><em>For any call to<strong>l.RLock</strong>on a<strong>sync.RWMutex</strong>variable<strong>l</strong>, there is an n such that the<strong>l.RLock</strong>happens (returns) after call n to<strong>l.Unlock</strong>and the matching<strong>l.RUnlock</strong>happens before call n+1 to<strong>l.Lock</strong>.</em></p>
<p>对于sync.RWMutex变量l上的任何对l.RLock的调用，有一个n，使得l.RLock发生在对l.Unlock的调用n之后（返回），而与之匹配的l.RUnlock发生在对l.Lock的调用n+1之前。</p>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><h3 id="Once-1"><a href="#Once-1" class="headerlink" title="Once"></a>Once</h3><p>The sync package provides a safe mechanism for initialization in the presence of multiple goroutines through the use of the Once type. Multiple threads can execute once.Do(f) for a particular f, but only one will run f(), and the other calls block until f() has returned.</p>
<p>sync包通过使用Once类型为多个goroutine存在时的初始化提供了一个安全机制。多个线程可以对某个f执行一次.Do(f)，但只有一个线程会运行f()，其他线程调用阻塞，直到f()返回。</p>
<p><em>A single call of<strong>f()**from</strong>once.Do(f)<strong>happens (returns) before any call of</strong>once.Do(f)**returns.</em></p>
<p>从 once.Do(f)的单次调用f()，在任何一次调用 once.Do(f)返回之前发生（返回）。</p>
<p>In this program:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	once.Do(setup)</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>calling twoprint will call setup exactly once. The setup function will complete before either call of print. The result will be that “hello, world” will be printed twice.</p>
<p>调用twoprint会调用setup一次。设置函数将在两次调用print之前完成。结果是 “hello, world “将被打印两次。</p>
<h3 id="Incorrect-synchronization"><a href="#Incorrect-synchronization" class="headerlink" title="Incorrect synchronization"></a>Incorrect synchronization</h3><h3 id="不正确的同步化"><a href="#不正确的同步化" class="headerlink" title="不正确的同步化"></a>不正确的同步化</h3><p>Note that a read <em>r</em> may observe the value written by a write <em>w</em> that happens concurrently with <em>r</em>. Even if this occurs, it does not imply that reads happening after <em>r</em> will observe writes that happened before <em>w</em>.</p>
<p>请注意，读r可能会观察到与r同时发生的写w所写的值。即使出现这种情况，也不意味着r之后发生的读会观察到w之前发生的写。</p>
<p>In this program:</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>it can happen that g prints 2 and then 0.</p>
<p>有可能发生g打印2，然后打印0的情况。</p>
<p>This fact invalidates a few common idioms.</p>
<p>这一事实使一些常见的写法失效。</p>
<p>Double-checked locking is an attempt to avoid the overhead of synchronization. For example, the twoprint program might be incorrectly written as:</p>
<p>Double-checked是为了避免同步的开销。例如，twoprint程序可能会被错误地写成: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !done &#123;</span><br><span class="line">		once.Do(setup)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>but there is no guarantee that, in doprint, observing the write to done implies observing the write to a. This version can (incorrectly) print an empty string instead of “hello, world”.</p>
<p>但不能保证在doprint中，观察写到done就意味着观察写到a，这个版本会错误地打印一个空字符串，而不是 “hello, world”。</p>
<p>Another incorrect idiom is busy waiting for a value, as in:</p>
<p>另一个不正确的写法是忙着等值，如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As before, there is no guarantee that, in main, observing the write to done implies observing the write to a, so this program could print an empty string too. Worse, there is no guarantee that the write to done will ever be observed by main, since there are no synchronization events between the two threads. The loop in main is not guaranteed to finish.</p>
<p>和之前一样，不能保证在main中，观察写到done的情况就意味着观察写到a的情况，所以这个程序也会打印一个空字符串。更糟糕的是，不能保证写到done的过程会被main观察到，因为两个线程之间没有同步事件。main中的循环不能保证完成。</p>
<p>There are subtler variants on this theme, such as this program.</p>
<p>这个程序还有更巧妙的变体，比如这个程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := <span class="built_in">new</span>(T)</span><br><span class="line">	t.msg = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	g = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> g == <span class="literal">nil</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(g.msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Even if main observes g != nil and exits its loop, there is no guarantee that it will observe the initialized value for g.msg.</p>
<p>即使main观察到g != nil并退出它的循环，也不能保证它会观察到g.msg的初始化值。</p>
<p>In all these examples, the solution is the same: use explicit synchronization.</p>
<p>在所有这些例子中，解决方案都是一样的：使用显式同步。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/12/04/go-error/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/04/go-error/" class="post-title-link" itemprop="url">go error</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-04 16:08:59" itemprop="dateCreated datePublished" datetime="2020-12-04T16:08:59+08:00">2020-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计划-——-go-error处理"><a href="#计划-——-go-error处理" class="headerlink" title="计划 —— go error处理"></a>计划 —— go error处理</h1><p>#个人/文章</p>
<p>Go error的处理方式不同于其他常用语言，一直饱受争议，这篇文章主要是说服大家，go error的处理方式很牛逼以及正确使用go error的姿势。</p>
<h2 id="go-error-长什么样"><a href="#go-error-长什么样" class="headerlink" title="go error 长什么样"></a>go error 长什么样</h2><p>先来看看go error长什么样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个函数返回了错误</span></span><br><span class="line">ret, err := doSomethingErr()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 进入到错误处理流程</span></span><br><span class="line">	doSomethineForErr(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无错误，继续正常流程</span></span><br><span class="line">continueTo()</span><br></pre></td></tr></table></figure>

<p>在go中，通过将错误返回的方式来处理错误信息，错误信息可由开发中自行决定如何处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而error在go中，仅仅是一个普通的接口而已。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// because the former will succeed if err wraps an *os.PathError.</span></span><br><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="comment">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意这里返回的是一个地址！！！</span></span><br><span class="line">	<span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们<code>new</code>一个error时，也只是创建一个error接口的实现，在go中被称为<code>errorString</code>的结构体。</p>
<h2 id="Error-amp-Exception"><a href="#Error-amp-Exception" class="headerlink" title="Error &amp; Exception"></a>Error &amp; Exception</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%80%E4%B8%AA%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%80%E4%B8%AA%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">数据结构与算法-一个顺序表实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-19 14:39:01" itemprop="dateCreated datePublished" datetime="2020-06-19T14:39:01+08:00">2020-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/" itemprop="url" rel="index"><span itemprop="name">代码片段</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>arrayList/arrayList.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> arrayList</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/pkg/errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// list接口</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">interface</span> &#123;</span><br><span class="line">	Size() <span class="keyword">int</span>                                 <span class="comment">// 数组大小</span></span><br><span class="line">	Get(index <span class="keyword">int</span>) (<span class="keyword">interface</span>&#123;&#125;, error)        <span class="comment">// 获取数据</span></span><br><span class="line">	Set(index <span class="keyword">int</span>, value <span class="keyword">interface</span>&#123;&#125;) error    <span class="comment">// 修改数据</span></span><br><span class="line">	Del(index <span class="keyword">int</span>) error                       <span class="comment">// 删除数据</span></span><br><span class="line">	Insert(index <span class="keyword">int</span>, value <span class="keyword">interface</span>&#123;&#125;) error <span class="comment">// 插入数据</span></span><br><span class="line">	Append(value <span class="keyword">interface</span>&#123;&#125;)                  <span class="comment">// 追加数据</span></span><br><span class="line">	Clear()                                    <span class="comment">// 清空数据</span></span><br><span class="line">	String() <span class="keyword">string</span>                            <span class="comment">// 返回字符串，打印用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrayList 结构</span></span><br><span class="line"><span class="keyword">type</span> ArrayList <span class="keyword">struct</span> &#123;</span><br><span class="line">	dataStore []<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 数据存储</span></span><br><span class="line">	size      <span class="keyword">int</span>           <span class="comment">// 数据大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArrayList</span><span class="params">()</span> *<span class="title">ArrayList</span></span> &#123;</span><br><span class="line">	list := <span class="built_in">new</span>(ArrayList)</span><br><span class="line">	list.dataStore = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	list.size = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> list.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">Get</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= list.size &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;索引越界&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> list.dataStore[index], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">Set</span><span class="params">(index <span class="keyword">int</span>, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= list.size &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;索引越界&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list.dataStore[index] = value</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">Del</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= list.size &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;索引越界&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list.dataStore = <span class="built_in">append</span>(list.dataStore[:index], list.dataStore[index+<span class="number">1</span>:]...)</span><br><span class="line">	list.size--</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">Insert</span><span class="params">(index <span class="keyword">int</span>, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= list.size &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;索引越界&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 通过append插入,需要开辟新的内存空间</span></span><br><span class="line">	<span class="comment">//list.dataStore = append(list.dataStore[:index], append([]interface&#123;&#125;&#123;value&#125;, list.dataStore[index:]...)...)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 切片通过copy原地插入</span></span><br><span class="line">	list.dataStore = <span class="built_in">append</span>(list.dataStore, <span class="literal">nil</span>)</span><br><span class="line">	<span class="built_in">copy</span>(list.dataStore[index+<span class="number">1</span>:], list.dataStore[index:])</span><br><span class="line">	list.dataStore[index] = value</span><br><span class="line"></span><br><span class="line">	list.size++</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">Append</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	list.dataStore = <span class="built_in">append</span>(list.dataStore, value)</span><br><span class="line">	list.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list.dataStore = []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	list.size = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint(list.dataStore)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><p>arrayList/arrayList_test.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> arrayList</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArrayList</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	list := NewArrayList()</span><br><span class="line">	list.Append(<span class="number">1</span>)</span><br><span class="line">	list.Append(<span class="number">2</span>)</span><br><span class="line">	list.Append(<span class="number">3</span>)</span><br><span class="line">	list.Set(<span class="number">1</span>, <span class="number">2.1</span>)</span><br><span class="line"></span><br><span class="line">	list.Insert(<span class="number">1</span>, <span class="number">1.1</span>)</span><br><span class="line">	list.Del(<span class="number">1</span>)</span><br><span class="line">	list.Set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Print(list.String())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%B3%E4%BA%8EHTTP%E7%9A%84%E4%B8%80%E5%88%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%B3%E4%BA%8EHTTP%E7%9A%84%E4%B8%80%E5%88%87/" class="post-title-link" itemprop="url">[计算机网络2]我所知道的关于HTTP的一切</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-15 14:44:49" itemprop="dateCreated datePublished" datetime="2020-06-15T14:44:49+08:00">2020-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>The Hypertext Transfer Protocol (HTTP) is a stateless applicationlevel protocol for distributed, collaborative, hypertext information systems. (<a href="(https://tools.ietf.org/html/rfc7230)">RFC7230 2014.6</a>)</p>
<p><strong>HTTP协议</strong>是一种无状态的、应用层的、以请求/应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。</p>
<h2 id="浏览器是怎么发起HTTP请求的"><a href="#浏览器是怎么发起HTTP请求的" class="headerlink" title="浏览器是怎么发起HTTP请求的"></a>浏览器是怎么发起HTTP请求的</h2><p>先看一看时序图</p>
<img  src=http://www.plantuml.com/plantuml/svg/ZL7BJi9G4DttA-uF44rqOLYuqGKcrH1RFw0-5cmCKJw0692NfIKWYJnQ2Y6OGAYQLA0quMUOwUsANx1GWKA2SN6JkPCpvp73H8M7MEGc4XNkOmGDYNRIyFRER7Hh8cIrUVTMY0dNmkCTERtW66Q59e7ZzMYGEF4AdQIkBbdQQQ4YGye4LGLPP5P4Yu7b9qZiQW7atj4-fik7XmTsLmUfjKNl2WO9DaOezZqoLDjKRyvzk8y4DXtGIGcgYWS4VGHcoQuapi9G-u1wVDlusiTqcC6UXfA6cHoCJRkRuq_2TA9WlZspqjDn6wGipt9x7CTwe9cLyOVoczYz7bGIJhmHulamrGVu-RJR3qW5QWnyo1rQoy0U2egY6_WF_MK9rYiMyxz7MWpDh1SSVg5Q3F7dhACPJhqvRtbhNo3WEGdzaHS1aj_JSVd_GMX-05BPetLvg950KtOFusFu0G00>

<h2 id="HTTP消息格式"><a href="#HTTP消息格式" class="headerlink" title="HTTP消息格式"></a>HTTP消息格式</h2><h3 id="一般表达"><a href="#一般表达" class="headerlink" title="一般表达"></a>一般表达</h3><p>请求 request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># start-line request-line</span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1 \r\n</span><br><span class="line"></span><br><span class="line"># header-field</span><br><span class="line">Host: haishenming.xyz</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># message-body</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>响应 response</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># start-line status-line</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line"></span><br><span class="line"># header-field</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># message-body</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ABNF表达-扩充巴科斯-瑙尔范式"><a href="#ABNF表达-扩充巴科斯-瑙尔范式" class="headerlink" title="ABNF表达(扩充巴科斯-瑙尔范式)"></a>ABNF表达(扩充巴科斯-瑙尔范式)</h3><p><strong>ABNF规则介绍</strong></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F#%E6%A0%B8%E5%BF%83%E8%A7%84%E5%88%99">扩充巴科斯范式-维基百科</a></p>
<p>HTTP-message=<em>start-line</em> *( <em>header-filed</em> CRLF ) CRLF [ <em>message-body</em> ]</p>
<ul>
<li><em>start-line</em>=request-line / status-line<ul>
<li>request-line=method SP resquest-status SP HTTP-version CRLF</li>
<li>status-line=HTTP-version SP status-code SP reason-phrase CRL</li>
</ul>
</li>
<li><em>header-filed</em>=field-name “:” OWS field-value OWS<ul>
<li>OWS=*(SP / HTAB)</li>
<li>field-name=token</li>
<li>field-value=*(field-content / obs-fold )</li>
</ul>
</li>
<li><em>message-body</em>=*OCTET</li>
</ul>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>要讲HTTP，就必须提到TCP/IP。</p>
<ul>
<li>应用层<ul>
<li>HTTP</li>
<li>SMTP</li>
<li>Telnet</li>
<li>FTP</li>
<li>DNS</li>
<li>…</li>
</ul>
</li>
<li>传输层<ul>
<li>TCP</li>
<li>UDP</li>
</ul>
</li>
<li>网络层<ul>
<li>IP</li>
<li>ARP</li>
</ul>
</li>
<li>数据链路层<ul>
<li>Ethernet</li>
<li>…</li>
</ul>
</li>
<li>物理层<ul>
<li>TCP/IP中没有对物理层的描述</li>
</ul>
</li>
</ul>
<h2 id="HTTP-web架构设计"><a href="#HTTP-web架构设计" class="headerlink" title="HTTP web架构设计"></a>HTTP web架构设计</h2><h3 id="评估Web架构的关键属性"><a href="#评估Web架构的关键属性" class="headerlink" title="评估Web架构的关键属性"></a>评估Web架构的关键属性</h3><ol>
<li>性能 Performance: 影响高可用的关键因素</li>
<li>可伸缩性 Scalability: 支持部署可以相互交互的大量组件</li>
<li>简单性 Simplicity: 容易理解，实现和验证</li>
<li>可见性 Visiable: 对两个组件间的交互进行监视或者仲裁的能力，如缓存，分层设计等</li>
<li>可以执行 Portability: 在不同的环境下运行的能力</li>
<li>可靠性 Reliablity: 出现部分故障时，对整体影响的程度</li>
<li>可修改性 Modifiability: 对系统作出修改的难易程度，由可进化性，可定制性，可扩展性，可配置性和可重构性组成<ul>
<li>可进化性 Evolvability: 一个组件单独升级而不影响其他组件</li>
<li>可扩展性 Extensibility: 向系统添加功能，而不会影响到系统的其他部分</li>
<li>可定制性 Customizability: 临时性，定制性地修改某一元素来提供服务，部队常规客户产生影响</li>
<li>可配置性 Configurability: 应用部署后可通过修改配置提供新的功能</li>
<li>可重用性 Reusability: 组件可以捕捉修改在其他应用中使用</li>
</ul>
</li>
</ol>
<p>HTTP协议的架构设计应该在上述属性中取得可接受的均衡。</p>
<h3 id="评估Web架构性能的属性"><a href="#评估Web架构性能的属性" class="headerlink" title="评估Web架构性能的属性"></a>评估Web架构性能的属性</h3><ul>
<li>网络性能 Network Performance<ul>
<li>吞吐量 Throughput: 小于等于带宽</li>
<li>开销 Overhead: 首次开销，每次开销</li>
</ul>
</li>
<li>用户感知到的性能 User-perceived Performance<ul>
<li>延迟 Latency: 发起请求到接受到响应的时间</li>
<li>完成时间 Completion: 完成一个应用动作所花费的时间</li>
</ul>
</li>
<li>网络效率 Network Efficiency<ul>
<li>重用缓存，减少交互次数，数据传输距离，COD</li>
</ul>
</li>
</ul>
<h3 id="REST-架构"><a href="#REST-架构" class="headerlink" title="REST 架构"></a>REST 架构</h3><p>REST：Representational State Transfer 表现层状态转移</p>
<p>Resource Representational State Transfer 资源在网络中以某种表现形式进行状态转移</p>
<p>REST架构最早的出处，来自Roy Fielding的毕业论文，<br><a target="_blank" rel="noopener" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Architectural Styles and the Design of Network-based Software Architectures</a></p>
<p><img src="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_process_view.gif"></p>
<p>图为该论文中所描述的REST架构图</p>
<h4 id="五种架构风格"><a href="#五种架构风格" class="headerlink" title="五种架构风格"></a>五种架构风格</h4><ul>
<li>数据流风格 Data-flow<ul>
<li>简单性</li>
<li>可进化性</li>
<li>可扩展性</li>
<li>可配置性</li>
<li>可重用性</li>
</ul>
</li>
<li>复制风格 Replication<ul>
<li>用户可察觉的性能</li>
<li>可伸缩性</li>
<li>网络效率</li>
<li>可靠性</li>
</ul>
</li>
<li>分层风格 Hierarchical<ul>
<li>简单性</li>
<li>可进化性</li>
<li>可伸缩性</li>
</ul>
</li>
<li>移动代码风格 Mobile Code<ul>
<li>可移植性</li>
<li>可扩展性</li>
<li>网络效率</li>
</ul>
</li>
<li>点对点风格 Peer-to-Peer<ul>
<li>可进化性</li>
<li>可重用性</li>
<li>可扩展性</li>
<li>可配置性</li>
</ul>
</li>
</ul>
<p>在这里不做详细介绍。</p>
<h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p><strong>URL</strong>: RFC1738(1994.12), Uniform Resource Locator, 表示资源位置，期望提供查找资源的方法。</p>
<p><strong>URN</strong>: RFC2141(1997.5), Uniform Resource Name, 期望为资源提供持久的，位置无关的标识方式，并允许简单地将多个命名空间映射到单个URN命名空间。</p>
<p><strong>URI</strong>: RFC1630(1994.6), RFC3986(2005.1)，取代RFC2396和RFC2732， Uniform Resource Identifier, 用以区分资源，是URL和URN的超集，用以渠道URL和URN概念。</p>
<h3 id="Uniform-Resource-Identifier-统一资源标识符"><a href="#Uniform-Resource-Identifier-统一资源标识符" class="headerlink" title="Uniform Resource Identifier 统一资源标识符"></a>Uniform Resource Identifier 统一资源标识符</h3><p><strong>Resource</strong><br>资源，可以是文档，图片，数据等，也可以是人员，门店，摄像头等现实世界物质在互联网中的抽象。</p>
<p><strong>Identifier</strong><br>标识符，将当前资源与其他资源区分开的名称。</p>
<p><strong>Uniform</strong><br>统一，包含几种统一的含义：</p>
<ol>
<li>不同资源可以在同一个上下文中出现</li>
<li>不同的资源标识符可以使用同一种语义进行解读</li>
<li>引入新标识的时候，不会对已有的标识符产生影响</li>
<li>允许同一资源标识符在不同的，internet规模下的上下文中出现</li>
</ol>
<h3 id="URI组成"><a href="#URI组成" class="headerlink" title="URI组成"></a>URI组成</h3><p><code>scheme://user:password@host:port/path?query1=1&amp;query2=2#fragment</code></p>
<h3 id="URI的ABNF表达"><a href="#URI的ABNF表达" class="headerlink" title="URI的ABNF表达"></a>URI的ABNF表达</h3><p>URI=<code>scheme</code>“:”<code>hier-part</code>[“?”<code>query</code>][“#”<code>fragment</code>]</p>
<ul>
<li>scheme=ALPHA*(ALPHA/DIGIT/“+”/“-“/“.”)<ul>
<li>http,https,ftp,mailto,rtsp,file,telnet</li>
</ul>
</li>
<li>query=*(pchar/“/“/“?”)</li>
<li>fragment=*(pchar/“/“/“?”)</li>
<li>hier-part=”//“authority path-abempty / path-absolute / path-rootless / path-empty<ul>
<li>authority=[userinfo”@”]host[“:”port]<ul>
<li>userinfo=*(unreserved / pct-encoded / sub-delims / “:”)</li>
<li>host=IP-literal / IPv4address / reg-name</li>
<li>port *DIGIT</li>
</ul>
</li>
<li>path=path-abempty / path-absolute / path-rootless / path-empty / path-noscheme</li>
</ul>
</li>
</ul>
<h3 id="URI编码"><a href="#URI编码" class="headerlink" title="URI编码"></a>URI编码</h3><p>在数据传递过程中，容易遇到URI保留字符或者存在歧义性字符，因此需要对一些字符进行编码</p>
<ul>
<li>不在ASCII码范围内的字符</li>
<li>ASCII码中不可显示的字符</li>
<li>URI中规定的保留字</li>
<li>不安全的字符，如空格，引号，尖括号等。</li>
</ul>
<p><strong>保留字符</strong></p>
<p>reserved = gen-delims / sub-delims</p>
<ul>
<li>gen-delims = “:” / “/“ / “?” / “#” / “[“ / “]” / “@”</li>
<li>sub-delims = “!” / “$” / “&amp;” / “”” / “(“ / “)” / “*” / “+” / “,” / “;” / “=”</li>
</ul>
<p><strong>非保留字符</strong></p>
<p>unreserved = ALPHA / DIGIT / “-“ / “.” / “_” / “~”</p>
<ul>
<li>“~”： 有的实现将此认定为保留字符，因此<code>～</code>也需要编码</li>
</ul>
<p><strong>URI百分号编码</strong></p>
<p>pct-encoded = “%” HEXDIG HEXDIG</p>
<ul>
<li>US-ASCII: 128个字符</li>
<li>HEXDIG： 十六进制，大小写等价</li>
<li>非ASCII字符：先UTF-8编码，再US-ASCII编码</li>
<li>URI合法字符，编码和不编码是等价的</li>
</ul>
<h2 id="HTTP请求行和响应行"><a href="#HTTP请求行和响应行" class="headerlink" title="HTTP请求行和响应行"></a>HTTP请求行和响应行</h2><p><strong>请求行</strong></p>
<p>request-line = method SP request-target SP HTTP-version CRLF</p>
<ul>
<li>method: 请求方法</li>
<li>request-target: origin-form / absolute-form / authority-form / asterisk-form<ul>
<li>origin-form = absolute-path [“?” query]<ul>
<li>向origin server发起的请求，path为空时必须传递<code>/</code></li>
</ul>
</li>
<li>absolute-form = absolute-URI<ul>
<li>仅用于向正向代理proxy发起请求时</li>
</ul>
</li>
<li>authority-form = authority<ul>
<li>仅用于CONNECT方法，如<code>CONNECT www.wxample.com:80 HTTP/1.1</code></li>
</ul>
</li>
<li>asterisk-form = “*”<ul>
<li>仅用于OPTIONS方法</li>
</ul>
</li>
</ul>
</li>
<li>HTTP-version: HTTP版本号</li>
</ul>
<p><strong>请求方法</strong></p>
<ul>
<li>GET<ul>
<li>主要获取信息的方法，幂等</li>
</ul>
</li>
<li>HEAD<ul>
<li>获取元数据，可认为是不返回BODY的GET方法，幂等</li>
</ul>
</li>
<li>POST<ul>
<li>常用于提交表单等向服务器发送数据，新增资源</li>
</ul>
</li>
<li>PUT<ul>
<li>更新资源</li>
</ul>
</li>
<li>DELETE<ul>
<li>删除资源</li>
</ul>
</li>
<li>CONNECT<ul>
<li>建立tunnel隧道</li>
</ul>
</li>
<li>OPTIONS：<ul>
<li>显示服务器访问资源时支持的方法，幂等</li>
</ul>
</li>
<li>TRACE<ul>
<li>追踪服务器收到的请求，用于定位问题，存在安全风险。</li>
</ul>
</li>
</ul>
<p><strong>响应行</strong></p>
<p>status-line = HTTP-version SP status-code SP reason-phrase CRLF</p>
<ul>
<li>status-code = 3DIGIT</li>
<li>reason-phrase = *(HTAB / SP / VCHAR / obs-text)</li>
</ul>
<p><strong>响应码</strong></p>
<ul>
<li>响应码规范： RFC6585(2012.4), RFC7231(2014.6)</li>
<li>1xx: 已收到请求，需要进一步处理才能完成，HTTP1.0不支持<ul>
<li>100 Continue: 上传大文件前使用<ul>
<li>由客户端发起请求中携带<code>Expect: 100-continue</code>头部触发</li>
</ul>
</li>
<li>101 Switch Protocols: 升级协议时使用<ul>
<li>由客户端发起请求中携带<code>Upgrade</code>头部触发，如升级websocket或者HTTP/2.0</li>
</ul>
</li>
<li>102 Processing: WebDAV请求可能包含许多设计文件操作的之请求，需要长时间完成请求。该响应码表示服务器以及收到并正在处理请求，但无响应可用。这样可以防止客户端超时</li>
</ul>
</li>
<li>2xx: 成功处理请求<ul>
<li>200 OK： 成功返回</li>
<li>201 Created: 有新资源在服务端被成功创建</li>
<li>202 Accepted: 服务器接受并开始处理请求，但请求未处理完成，如异步，需要长时间处理的任务等</li>
<li>203 Non-Authoritative Information: 但代理服务器修改了<code>origin server</code>的原始响应包体时，代理服务器可以通过修改200为203来告知客户端这一事情，方便客户端作出进一步处理。203可以被缓存。</li>
<li>204 No Content: 成功执行了请求且不携带响应包体，暗示客户端无需更新当前的页面</li>
<li>205 Reset Content: 成功执行了请求并且不携带响应包体，指明客户端需要更新当前页面视图</li>
<li>206 Partial Coneten: 使用range协议时返回部分响应内容时的响应码</li>
<li>207 Multi-Status: RFC4918, 在WebDAV协议中以XML返回多个资源的状态</li>
<li>208 Already Reported: RFC5842, 为避免相同集合下资源在207响应码下重复上报，使用208可以使用父集合的响应码</li>
</ul>
</li>
<li>3xx: 重定向。在RFC2068中规定客户端重定向次数不应超过5次，以防止死循环<ul>
<li>300 Multiple Choices: 资源有多种表述，客户端受到后自行选择使用哪一种表述。很少使用</li>
<li>301 Moved Permanently: 资源永久性重定向到另一个URI中</li>
<li>302 Found: 资源临时重定向到另一个URI中</li>
<li>303 See Other: 重定向到其他资源，常用于POST/PUT等方法的响应中</li>
<li>304 Not Modified: 但客户端拥有可能过期的缓存时，会携带缓存的标识etag，时间等询问服务器缓存时候仍可以使用。304是告诉客户端可以使用。</li>
<li>307 Temporary Redirect： 类似302，但名求重定向后的请求方法必须与原请求方法相同。</li>
<li>308 Permanent Redirect: 类似301，但名求重定向后的请求方法必须与原请求方法相同。</li>
</ul>
</li>
<li>4xx: 客户端错误<ul>
<li>400 Bad Request: 服务器认为客户端出现错误，但不能明确判断是哪种错误。</li>
<li>401 Unauthorized: 认证信息缺失或不正确</li>
<li>403 Forbidden: 服务器理解请求含义，但客户端没有权限执行此请求</li>
<li>404 Not Found: 服务器没有找到响应的资源</li>
<li>405 Method Not Allowed: 服务器不支持method方法</li>
<li>406 Not Acceptable: 对客户端制定的资源表述不存在，如对语言或者编码有要求，服务器返回表述列表供客户端参考</li>
<li>407 Proxy Authentication Required: 对需要经过代理的请求，认证信息未通过代理服务器的验证</li>
<li>408 Request Timeout: 请求超时</li>
<li>409 Coflic: 资源冲突</li>
<li>410 Gone: 服务器没有找到对应的资源，并且明确的知道该位置永久性找不到该资源</li>
<li>411 Length Required: 如果请求包含包体且未携带Content-Lenght头部，且不属于chunk类请求，返回411</li>
<li>413 Payload Too Large/Request Entity Too Large: 请求包体超出服务器能处理的最大长度</li>
<li>414 URI Too Long: 请求URI超出服务器能接受的最大长度</li>
<li>415 Unsupported Media Type: 上传的文件类型不被服务器支持</li>
<li>416 Range No Satisfiable: 无法提供Range请求中指定的那段包体</li>
<li>421 Misdirected Request: 服务器认为这个请求不应该发给自己，服务器没有能力处理这个请求</li>
<li>426 Upgrade Required: 服务器拒绝基于当前HTTP协议提供服务，通过Upgrade头部告知客户端必须升级协议才能继续处理</li>
<li>429 Too Many Requests: 客户端发送请求速率过快</li>
<li>431 Request Header Fields Too Large: 请求的HEADER头部超过限制</li>
<li>451 Unavailable For Legal Reasons: RFC7725, 由于法律原因资源不可访问</li>
</ul>
</li>
<li>5xx: 服务端出现错误<ul>
<li>500 Internal Server Error: 服务器内部错误，且不属于以下错误类型</li>
<li>501 Not Implemented: 服务器不支持实现请求所需要的功能</li>
<li>502 Bad Gateway: 代理服务器无法获取到合法响应</li>
<li>503 Service Unavailable: 服务器资源尚未准备好处理当前请求</li>
<li>504 Getewag Timeout: 代理服务器从上游获取请求超时</li>
<li>505 HTTP Version Not Supported: 请求使用的HTTP协议版本不支持</li>
<li>507 Insufficient Storage: 服务器没有足够的空间处理请求</li>
<li>508 Loop Detected: 访问资源时检测到循环</li>
<li>511 NetWork Authentication Required: 代理服务器发现客户端需要进行身份验证才能获取网络访问权限</li>
</ul>
</li>
</ul>
<h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>Connection头部</p>
<ul>
<li>Keep-Alive: 长链接<ul>
<li>客户端请求长链接<ul>
<li>Connection: Keep-Alive</li>
</ul>
</li>
<li>服务器表示支持长链接<ul>
<li>Connection: Keep-Alive</li>
</ul>
</li>
<li>HTTP/1.1默认使用长链接</li>
</ul>
</li>
<li>Close: 短链接</li>
</ul>
<p>此规则仅仅表示客户端与直接相连的服务器之间建立长链接，如果中间存在代理，则有可能代理与代理，代理与最终服务器直接不是长链接，需要另作处理</p>
<p>Proxy-Connection解决老旧代理无法处理Keep-Alive的情况</p>
<hr>
<p>未完待续！</p>
<hr>
<blockquote>
<p>参考</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/understanding-restful-style">理解本真的 REST 架构风格</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/05/12/MIT-6-824-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F3-%E8%AF%91%E6%96%87-The-Google-File-System/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/12/MIT-6-824-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F3-%E8%AF%91%E6%96%87-The-Google-File-System/" class="post-title-link" itemprop="url">[MIT-6.824-分布式系统3]译文 The Google File System</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-12 11:11:10" itemprop="dateCreated datePublished" datetime="2020-05-12T11:11:10+08:00">2020-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>The Google File System</code>，<code>GFS</code>，是google设计的大型分布式存储系统，该论文发布与2003年，虽然已经过去了近20年，google也与2013年发布了<code>Colossus</code>作为<code>GFS</code>的替代品的下一代文件系统，但是<code>GFS</code>中的一些设计依然值得我们学习。</p>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><h3 id="大型分布式文件系统难在哪里？"><a href="#大型分布式文件系统难在哪里？" class="headerlink" title="大型分布式文件系统难在哪里？"></a>大型分布式文件系统难在哪里？</h3><ul>
<li>性能 –&gt; 文件分散的存储在不同的设备上，如何保障读写性能？</li>
<li>容错 –&gt; 我们拥有成千上万的机器和硬盘，不可避免会出现读写错误的情况，这时候怎么办？</li>
<li>一致性 –&gt; 如果使用冗余的方式进行容错，如何保证多机数据的一致性？</li>
<li>……</li>
</ul>
<h3 id="GFS做了什么？"><a href="#GFS做了什么？" class="headerlink" title="GFS做了什么？"></a>GFS做了什么？</h3><p>快速存取大量数据</p>
<ul>
<li>全局（Global） –&gt; 所有设备构成一个统一的全局文件系统</li>
<li>分片（sharding） –&gt; 文件可以被分割存储在不同的设备上，以方便设置冗余，突破单个磁盘存储容量限制，同时也可以提升存取速度。</li>
<li>自动恢复（automatic recovery） –&gt; 大型存储机器中的机器故障可以自动恢复而无需人为干预。</li>
<li>单一数据中心（single data center） –&gt; 一套GFS只在单一的数据中心运行，而不考虑多地共享数据。因此不用考虑远距离的数据共享问题。</li>
<li>大型文件顺序读写 –&gt; 为大型文件顺序读写设计，而区别于小文件随机读写系统。</li>
</ul>
<p>下面是原文和译文</p>
<h1 id="The-Google-File-System"><a href="#The-Google-File-System" class="headerlink" title="The Google File System"></a>The Google File System</h1><p>Google 文件系统</p>
<h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>内容提要</p>
<p>We have designed and implemented the Google File System, a scalable distributed file system for large distributed data-intensive applications. It provides fault tolerance while running on inexpensive commodity hardware, and it delivers high aggregate performance to a large number of clients.</p>
<p>我们设计并实现了Google文件系统，这是一个可扩展的分布式文件系统，适用于大型分布式数据密集型应用。它在廉价的商品硬件上运行的同时提供了容错能力，并为大量的客户机提供了很高的聚合性能。</p>
<p>While sharing many of the same goals as previous distributed file systems, our design has been driven by observations of our application workloads and technological environment, both current and anticipated, that reflect a marked departure from some earlier file system assumptions. This has led us to reexamine traditional choices and explore radically different design points.</p>
<p>虽然与以前的分布式文件系统有许多相同的目标，但我们的设计出发点在于我们的应用工作负载和对技术环境的观察，包括当前的和将来预计会出现的。这些具体情况反映出与早期的一些文件系统设计有明显的偏离。这促使我们重新审视传统的选择，探索完全不同的设计点。</p>
<p>The file system has successfully met our storage needs. It is widely deployed within Google as the storage platform for the generation and processing of data used by our service as well as research and development efforts that require large data sets. The largest cluster to date provides hundreds of terabytes of storage across thousands of disks on over a thousand machines, and it is concurrently accessed by hundreds of clients.</p>
<p>GFS成功地满足了我们的存储需求。它被广泛地部署在谷歌内部，作为存储平台，用于生成和处理我们的服务所使用的数据以及需要大量数据集的研发工作。迄今为止，最大的集群在一千多台机器上的数千块磁盘上并提供了数百兆字节的存储，有数百个客户机同时访问。</p>
<p>In this paper, we present file system interface extensions designed to support distributed applications, discuss many aspects of our design, and report measurements from both micro-benchmarks and real world use.</p>
<p>在本文中，我们提出了旨在支持分布式应用的文件系统接口扩展，讨论了我们设计的许多方面，并报告了从小规模性能测试和现实世界使用中的测量结果。</p>
<h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h2><p>介绍</p>
<p>We have designed and implemented the Google File System (GFS) to meet the rapidly growing demands of Google’s data processing needs. GFS shares many of the same goals as previous distributed file systems such as performance, scalability, reliability, and availability. However, its design has been driven by key observations of our application workloads and technological environment, both current and anticipated, that reflect a marked departure from some earlier file system design assumptions. We have reexamined traditional choices and explored radically different points in the design space.</p>
<p>我们设计并实现了Google文件系统（GFS），以满足Google快速增长的数据处理需求。GFS与以前的分布式文件系统有许多相同的设计目标，如性能、可扩展性、可靠性和可用性。然而，它的设计是由我们对应用工作负载和技术环境的关键观察所驱动的，包括当前和预期的技术环境，反映出与早期的一些文件系统设计有了明显的偏离。我们重新审视了传统的选择，探索了设计空间中不同的设计思路。</p>
<p>First, component failures are the norm rather than the exception. The file system consists of hundreds or even thousands of storage machines built from inexpensive commodity parts and is accessed by a comparable number of client machines. The quantity and quality of the components virtually guarantee that some are not functional at any given time and some will not recover from their current failures. We have seen problems caused by application bugs, operating system bugs, human errors, and the failures of disks, memory, connectors, networking, and power supplies. Therefore, constant monitoring, error detection, fault tolerance, and automatic recovery must be integral to the system.</p>
<p>首先，组件故障是常态，而不是例外。文件系统由数百甚至数千台存储机组成，这些存储机都是由廉价的商用设备组装而成，并被相当数量的客户机同时访问。这些设备的数量和质量无形中决定任何时候都可能有某些设备无法正常工作，有些设备也无法从当前的故障中恢复。我们已经遇到了由应用程序bug、操作系统bug、人为的错误，以及磁盘、内存、连接器、网络、电源的故障等造成的问题。因此，持续的监控、错误检测、容错和自动恢复必须成为该系统的组成部分。</p>
<p>Second, files are huge by traditional standards. Multi-GB files are common. Each file typically contains many application objects such as web documents. When we are regularly working with fast growing data sets of many TBs comprising billions of objects, it is unwieldy to manage billions of approximately KB-sized files even when the file system could support it. As a result, design assumptions and parameters such as I/O operation and block sizes have to be revisited.</p>
<p>第二，我们的文件通常比较大。GB级别文件是很常见的。每个文件通常包含许多应用程序对象，如Web文档等。当我们经常处理由数十亿个对象组成的，TB级别的，快速增长的数据集时，即使文件系统可以支持数十亿个KB大小级别的文件，但要管理起来也是不方便的。因此，设计假设和参数（如I/O操作和块大小）必须重新审视。</p>
<p>Third, most files are mutated by appending new data rather than overwriting existing data. Random writes within a file are practically non-existent. Once written, the files are only read, and often only sequentially. A variety of data share these characteristics. Some may constitute large repositories that data analysis programs scan through. Some may be data streams continuously generated by running applications. Some may be archival data. Some may be intermediate results produced on one machine and processed on another, whether simultaneously or later in time. Given this access pattern on huge files, appending becomes the focus of performance optimization and atomicity guarantees, while caching data blocks in the client loses its appeal.</p>
<p>第三，大多数文件修改是通过追加而不是覆盖来进行的，几乎不存在随机写入的情况。一旦文件被写入，通常就只会被读取，而且往往是顺序读取。大部分数据都有这些特点。有些可能构成了数据分析程序扫描过的大型存储库。有些可能是由运行中的应用程序连续产生的数据流。有些可能是存档数据。有些可能是在一台机器上产生的中间结果，在另一台机器上处理，不管是同时进行还是晚些时候进行。考虑到这种对大型的访问模式，追加性能成为性能优化和原子性保证的重点，而不是客户端中的缓存数据块。</p>
<p>Fourth, co-designing the applications and the file system API benefits the overall system by increasing our flexibility. For example, we have relaxed GFS’s consistency model to vastly simplify the file system without imposing an onerous burden on the applications. We have also introduced an atomic append operation so that multiple clients can append concurrently to a file without extra synchronization between them. These will be discussed in more details later in the paper.</p>
<p>第四，应用程序和文件系统API的协同增加了我们设计的灵活性，对整个系统有好处。例如，我们放宽了GFS的一致性模型的要求，极大地简化了文件系统的一致性模型，而不会给应用带来繁重的负担。我们还引入了原子追加操作，使多个客户端可以同时追加到一个文件，而不需要额外的同步。这些将在本文的后面详细讨论。</p>
<p>Multiple GFS clusters are currently deployed for different purposes. The largest ones have over 1000 storage nodes, over 300 TB of disk storage, and are heavily accessed by hundreds of clients on distinct machines on a continuous basis.</p>
<p>我们目前部署了多个GFS集群，用于不同的需求。最大的有超过1000个存储节点，超过300TB的磁盘存储，并且有上百个客户机连续大量访问。</p>
<h2 id="2-DESIGN-OVERVIEW"><a href="#2-DESIGN-OVERVIEW" class="headerlink" title="2. DESIGN OVERVIEW"></a>2. DESIGN OVERVIEW</h2><p>设计概述</p>
<h3 id="2-1-Assumptions"><a href="#2-1-Assumptions" class="headerlink" title="2.1 Assumptions"></a>2.1 Assumptions</h3><p>预期</p>
<p>In designing a file system for our needs, we have been guided by assumptions that offer both challenges and opportunities. We alluded to some key observations earlier and now lay out our assumptions in more details.</p>
<p>在设计一个符合我们需求的文件系统时，我们一直以各种假设为指导，这些假设既带来了挑战，也带来了机遇。我们在前面提到了一些关键的意见，现在详细介绍一下我们的假设。</p>
<ul>
<li><p>The system is built from many inexpensive commodity components that often fail. It must constantly monitor itself and detect, tolerate, and recover promptly from component failures on a routine basis.</p>
</li>
<li><p>系统是由许多廉价的商品部件组成的，这些部件经常会出现故障。它必须能够监控自己的状态，定期检测、容错以及自动恢复。</p>
</li>
<li><p>The system stores a modest number of large files. We expect a few million files, each typically 100 MB or larger in size. Multi-GB files are the common case and should be managed efficiently. Small files must be supported, but we need not optimize for them.</p>
</li>
<li><p>系统存储了一定数量的大文件。我们预计有几百万个文件，每个文件的大小一般在100MB以上。GB级的文件是常见的情况，应该进行有效的管理。小文件必须支持，但我们不需要对其进行优化。</p>
</li>
<li><p>The workloads primarily consist of two kinds of reads: large streaming reads and small random reads. In large streaming reads, individual operations typically read hundreds of KBs, more commonly 1 MB or more. Successive operations from the same client often read through a contiguous region of a file. A small random read typically reads a few KBs at some arbitrary offset. Performance-conscious applications often batch and sort their small reads to advance steadily through the file rather than go back and forth.</p>
</li>
<li><p>工作负载有两种读取构成：大规模流式读取和小规模随机读取。在大规模流式读取中，一次读取通常会达到数百KB，更常见的是1MB或更多。来自同一客户端的连续操作通常会读取文件的连续区域。一个小规模随机读通常会在一个文件的任意位置读取几个KB。注重性能的应用程序通常会对小读进行批处理和排序，以稳定地读取文件，而不是来回读。</p>
</li>
<li><p>The workloads also have many large, sequential writes that append data to files. Typical operation sizes are similar to those for reads. Once written, files are seldom modified again. Small writes at arbitrary positions in a file are supported but do not have to be efficient.</p>
</li>
<li><p>这些工作负载也有许多大型的、连续的写入操作，将数据追加到文件中。通常的操作大小与读取的操作大小类似。一旦写入，文件很少会被再次修改。支持在文件中任意位置的小规模写入，但不对性能做要求。</p>
</li>
<li><p>The system must efficiently implement well-defined semantics for multiple clients that concurrently append to the same file. Our files are often used as producer-consumer queues or for many-way merging. Hundreds of producers, running one per machine, will concurrently append to a file. Atomicity with minimal syn- chronization overhead is essential. The file may be read later, or a consumer may be reading through the file simultaneously.</p>
</li>
<li><p>系统必须有效地定义好的语义，以便于支持多个客户端并行追加同一个文件。我们的文件经常被用作生产者-消费者队列或多向合并。每台机器上运行的数百个生产者将并发地追加到一个文件。原子性与最小的同步化开销是至关重要的。该文件可能会被随后读取，或者一个消费者可能在追加时同时读取该文件。</p>
</li>
<li><p>High sustained bandwidth is more important than low latency. Most of our target applications place a premium on processing data in bulk at a high rate, while few have stringent response time requirements for an individual read or write.</p>
</li>
<li><p>高持续带宽比低延迟更重要。我们的大多数目标应用都看重的是以高速度批量处理数据，而很少有人对单个读或写的响应时间有严格的要求。</p>
</li>
</ul>
<h3 id="2-2-Interface"><a href="#2-2-Interface" class="headerlink" title="2.2 Interface"></a>2.2 Interface</h3><p>接口</p>
<p>GFS provides a familiar file system interface, though it does not implement a standard API such as POSIX. Files are organized hierarchically in directories and identified by path-names. We support the usual operations to create, delete, open, close, read, and write files.</p>
<p>GFS提供了一个熟悉的文件系统接口，尽管它没有实现像POSIX这样的标准API。文件是按目录分层组织的，并通过路径名来标识。我们支持创建、删除、打开、关闭、读取和写入文件等常规操作。</p>
<p>Moreover, GFS has snapshot and record append operations. Snapshot creates a copy of a file or a directory tree at low cost. Record append allows multiple clients to append data to the same file concurrently while guaranteeing the atomicity of each individual client’s append. It is use- ful for implementing multi-way merge results and producer-consumer queues that many clients can simultaneously append to without additional locking. We have found these types of files to be invaluable in building large distributed applications. Snapshot and record append are discussed further in Sections 3.4 and 3.3 respectively.</p>
<p>此外，GFS还支持快照和记录追加操作。快照可以低成本地创建一个文件或目录树的副本。记录追加允许多个客户端同时追加数据到同一个文件，同时保证每个客户端的追加操作的原子性。它适用于实现多向合并结果和生产者-消费者队列，许多客户端可以同时追加数据，而不需要额外的锁定。我们发现这些类型的文件在构建大型分布式应用中是非常有价值的。快照和记录追加将分别在3.4和3.3节中进一步讨论。</p>
<h3 id="2-3-Architecture"><a href="#2-3-Architecture" class="headerlink" title="2.3 Architecture"></a>2.3 Architecture</h3><p>架构</p>
<p>A GFS cluster consists of a single master and multiple chunkservers and is accessed by multiple clients, as shown in Figure 1. Each of these is typically a commodity Linux machine running a user-level server process. It is easy to run both a chunkserver and a client on the same machine, as long as machine resources permit and the lower reliability caused by running possibly flaky application code is acceptable.</p>
<p>一个GFS集群由一个master和多个chunkserver组成，并同时有多个客户端访问，如图1所示。其中每一个节点通常是一台运行用户级服务器进程的商用Linux机器。在同一台机器上同时运行一个chunkserver和一个客户端是很容易的，只要机器资源允许，而且运行不稳定的应用程序代码所造成的低可靠性是可以接受的。</p>
<p>Files are divided into fixed-size chunks. Each chunk is identified by an immutable and globally unique 64 bit chunk handle assigned by the master at the time of chunk creation. Chunkservers store chunks on local disks as Linux files and read or write chunk data specified by a chunk handle and byte range. For reliability, each chunk is replicated on multiple chunkservers. By default, we store three replicas, though users can designate different replication levels for different regions of the file namespace.</p>
<p>文件被划分成固定大小的块。每个数据块都由master在创建数据块时分配的一个不可更改的、全局唯一的64位数据块句柄来标识。Chunkservers将数据块作为Linux文件存储在本地磁盘上，并通过块句柄和字节范围来读写块数据。为了保证可靠性，每个数据块会被复制到多个chunkservers上。默认情况下，我们存储三个副本，但用户可以为文件命名空间的不同区域指定不同的复制级别。</p>
<p><img src="https://images.haishenming.xyz/blog/20200514101848.png" alt="图1"></p>
<p>he master maintains all file system metadata. This includes the namespace, access control information, the maping from files to chunks, and the current locations of chunks. It also controls system-wide activities such as chunk lease management, garbage collection of orphaned chunks, and chunk migration between chunkservers. The master periodically communicates with each chunkserver in HeartBeat messages to give it instructions and collect its state.</p>
<p>master维护所有文件系统的元数据。这包括命名空间、访问控制信息、从文件到数据块的映射，以及数据块的当前位置。它还控制着整个系统的活动，比如说数据块租约管理，垃圾收集，以及数据块在服务器之间的迁移。master定期通过心跳消息与每个chunkserver进行通信，向其发出指令并收集状态。</p>
<p>GFS client code linked into each application implements the file system API and communicates with the master and chunkservers to read or write data on behalf of the application. Clients interact with the master for metadata operations, but all data-bearing communication goes directly to the chunkservers. We do not provide the POSIX API and therefore need not hook into the Linux vnode layer.</p>
<p>GFS库链接到每个应用程序中，它实现了文件系统API，并与msater和chunkservers通信，帮组应用程序读取或写入数据。客户端与master进行元数据操作的交互，但所有的数据承载通信都直接到chunkservers。我们不提供POSIX API，因此不需要连接到Linux vnode层。</p>
<p>Neither the client nor the chunkserver caches file data. Client caches offer little benefit because most applications stream through huge files or have working sets too large to be cached. Not having them simplifies the client and the overall system by eliminating cache coherence issues. (Clients do cache metadata, however.) Chunkservers need not cache file data because chunks are stored as local files and so Linux’s buffer cache already keeps frequently accessed data in memory.</p>
<p>客户端和chunkserver都不缓存文件数据。客户端缓存的好处不大，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。，从而简化了客户端和整个系统。(不过，客户端会缓存元数据。)chunkservers不需要缓存文件数据，因为数据块是作为本地文件存储的，所以Linux的缓冲区缓存已经将频繁访问的数据保存在内存中。</p>
<h3 id="2-4-Single-Master"><a href="#2-4-Single-Master" class="headerlink" title="2.4 Single Master"></a>2.4 Single Master</h3><p>单节点master</p>
<p>Having a single master vastly simplifies our design and enables the master to make sophisticated chunk placement and replication decisions using global knowledge. However, we must minimize its involvement in reads and writes so that it does not become a bottleneck. Clients never read and write file data through the master. Instead, a client asks the master which chunkservers it should contact. It caches this information for a limited time and interacts with the chunkservers directly for many subsequent operations.</p>
<p>拥有一个单节点的master大大简化了我们的设计，并使master能够利用全局知识做出复杂的区块放置和复制决策。但是，我们必须尽量减少它在读和写中的参与，以免成为瓶颈。客户端从不通过master读写文件数据。相反，客户端会询问master应该联系哪些chunkserver。它在有限的时间内缓存这些信息，并在随后的许多操作中直接与chunkserver进行交互。</p>
<p>Let us explain the interactions for a simple read with reference to Figure 1. First, using the fixed chunk size, the client translates the file name and byte offset specified by the application into a chunk index within the file. Then, it sends the master a request containing the file name and chunk index. The master replies with the corresponding chunk handle and locations of the replicas. The client caches this information using the file name and chunk index as the key.</p>
<p>让我们参照图1来解释一下简单的读取流程。首先，使用固定的chunk大小，客户端将应用程序指定的文件名和字节偏移量翻译成文件内的chunk索引。然后，它向master发送一个包含文件名和块索引的请求。master会回复相应的chunk句柄和副本的位置。客户端使用文件名和chunk索引作为关键来缓存这些信息。</p>
<p>The client then sends a request to one of the replicas, most likely the closest one. The request specifies the chunk handle and a byte range within that chunk. Further reads of the same chunk require no more client-master interaction until the cached information expires or the file is reopened. In fact, the client typically asks for multiple chunks in the same request and the master can also include the information for chunks immediately following those requested. This extra information sidesteps several future client-master interactions at practically no extra cost.</p>
<p>然后客户端向其中一个副本发送一个请求，很可能是最接近的一个副本。该请求指定了数据块的句柄和该数据块中的字节范围。在缓存信息过期或文件被重新打开之前，对同一数据块的进一步读取不需要更多的客户端和master交互。事实上，客户端通常会在同一请求中请求多个块，master也可以包含紧随请求的块之后的信息。这些额外的信息避免了未来客户机与主机的交互，几乎不需要额外的成本。</p>
<h3 id="2-5-Chunk-Size"><a href="#2-5-Chunk-Size" class="headerlink" title="2.5 Chunk Size"></a>2.5 Chunk Size</h3><p>2.5 Chunk大小</p>
<p>Chunk size is one of the key design parameters. We have chosen 64 MB, which is much larger than typical file system block sizes. Each chunk replica is stored as a plain Linux file on a chunkserver and is extended only as needed. Lazy space allocation avoids wasting space due to internal fragmentation, perhaps the greatest objection against such a large chunk size.</p>
<p>Chunk大小是设计的关键参数之一。我们选择了64 MB，这比典型的文件系统块大小要大得多。每个chunk副本都作为一个普通的Linux文件存储在chunkserver上，并且只在需要的时候进行扩展。空间的慢分配避免了由于内部碎片化造成的空间浪费，这或许是对如此大的chunk大小的最具有争议的一点。</p>
<p>A large chunk size offers several important advantages. First, it reduces clients’ need to interact with the master because reads and writes on the same chunk require only one initial request to the master for chunk location information. The reduction is especially significant for our workloads because applications mostly read and write large files sequentially. Even for small random reads, the client can comfortably cache all the chunk location information for a multi-TB working set. Second, since on a large chunk, a client is more likely to perform many operations on a given chunk, it can reduce network overhead by keeping a persistent TCP connection to the chunkserver over an extended period of time. Third, it reduces the size of the metadata stored on the master. This allows us to keep the metadata in memory, which in turn brings other advantages that we will discuss in Section 2.6.1.</p>
<p>较大的chunk大小提供了几个重要的优势。首先，它减少了客户机与master的交互需求，因为在同一块上的读和写只需要向master发送一次初始请求，就可以获得块位置信息。这种简化对于我们的工作负载来说尤其重要，因为应用程序大多是按顺序读写大文件。即使是较小的随机读取，客户端也可以很容易地缓存数TB的工作集的所有数据块位置信息。第二，由于在一个较大的chunk上，客户端更有可能在一个给定的chunk上执行许多操作，因此可以通过长时间保持与chunkserver的持久TCP连接来减少网络开销。第三，它减少了存储在主站上的元数据的大小。这使得我们可以将元数据保存在内存中，这反过来又带来了我们将在2.6.1节中讨论的其他优点。</p>
<p>On the other hand, a large chunk size, even with lazy space allocation, has its disadvantages. A small file consists of a small number of chunks, perhaps just one. The chunkservers storing those chunks may become hot spots if many clients are accessing the same file. In practice, hot spots have not been a major issue because our applications mostly read large multi-chunk files sequentially.</p>
<p>另一方面，大块chunk的文件，即使是采用慢分配空间，也有其缺点。一个小文件由较少的chunks组成，甚至只有一个。如果很多客户端访问同一个文件，存储这些chunkservers可能会成为热点。在实际应用中，热点问题并不是一个大问题，因为我们的应用大多是按顺序读取大的多块文件。</p>
<p>However, hot spots did develop when GFS was first used by a batch-queue system: an executable was written to GFS as a single-chunk file and then started on hundreds of machines at the same time. The few chunkservers storing this executable were overloaded by hundreds of simultaneous re- quests. We fixed this problem by storing such executables with a higher replication factor and by making the batchqueue system stagger application start times. A potential long-term solution is to allow clients to read data from other clients in such situations.</p>
<p>然而，当GFS第一次被批处理队列系统使用时，确实出现了一些热点：一个可执行文件被写成单个chunk文件写入GFS，然后在数百台机器上同时启动。存储这个可执行文件的少数chunkservers被上百个同时重启的请求超载了。我们通过使用更高的复制系数存储这类可执行文件，并使批处理队列系统错开应用程序的启动时间来修复这个问题。一个潜在的长期解决方案是允许客户端在这种情况下从其他客户端读取数据。</p>
<h3 id="2-6-Metadata"><a href="#2-6-Metadata" class="headerlink" title="2.6 Metadata"></a>2.6 Metadata</h3><p>2.6 元数据</p>
<p>The master stores three major types of metadata: the file and chunk namespaces, the mapping from files to chunks, and the locations of each chunk’s replicas. All metadata is kept in the master’s memory. The first two types (namespaces and file-to-chunk mapping) are also kept persistent by logging mutations to an operation log stored on the master’s local disk and replicated on remote machines. Using a log allows us to update the master state simply, reliably, and without risking inconsistencies in the event of a master crash. The master does not store chunk location information persistently. Instead, it asks each chunkserver about its chunks at master startup and whenever a chunkserver joins the cluster.</p>
<p>msater主要存储三种类型的元数据：文件和块的命名空间、从文件到块的映射，以及每个块的复制位置。所有的元数据都保存在master的内存中。前两种类型（命名空间和文件到块之间的映射）也是通过记录变更到存储在主站本地磁盘上的操作日志并复制到远程机器上的操作日志来保持持久性。通过变更日志日志，我们可以简单、可靠地更新msater状态，并且确保master崩溃时不会出现不一致的风险。master不会持久地存储chunk位置信息。相反，在master启动时和每当一个chunkserver加入集群时，都会询问每个chunkserver关于它的块的信息。</p>
<h4 id="2-6-1-In-Memory-Data-Structures"><a href="#2-6-1-In-Memory-Data-Structures" class="headerlink" title="2.6.1 In-Memory Data Structures"></a>2.6.1 In-Memory Data Structures</h4><p>2.6.1 内存数据结构</p>
<p>Since metadata is stored in memory, master operations are fast. Furthermore, it is easy and efficient for the master to periodically scan through its entire state in the background. This periodic scanning is used to implement chunk garbage collection, re-replication in the presence of chunkserver failures, and chunk migration to balance load and disk space usage across chunkservers. Sections 4.3 and 4.4 will discuss these activities further.</p>
<p>由于元数据存储在内存中，所以master操作速度很快。此外，master在后台周期性地扫描整个状态是很简单和高效的。这种周期性的扫描被用来实现chunkserver的垃圾回收，chunkserver出现故障时的重复制，以及chunkserver之间的负载和磁盘空间使用平衡的块迁移。第4.3和4.4节将进一步讨论这些活动。</p>
<p>One potential concern for this memory-only approach is that the number of chunks and hence the capacity of the whole system is limited by how much memory the master has. This is not a serious limitation in practice. The master maintains less than 64 bytes of metadata for each 64 MB chunk. Most chunks are full because most files contain many chunks, only the last of which may be partially filled. Similarly, the file namespace data typically requires less then 64 bytes per file because it stores file names compactly using prefix compression.</p>
<p>这种仅使用内存的方法的一个潜在的问题是，master的内存大小会限制了整个系统的数据块的数量，从而限制了整个系统的容量。这在实际应用中并不是一个严重的问题。每个64MB的数据块，master只维护不到64字节的元数据。大多数块是满的，因为大多数文件包含许多块，只有最后一个块可能被部分填满。同样的，文件命名空间数据通常每个文件所需的元数据也少于64字节，因为它使用前缀压缩方式紧凑地存储文件名。</p>
<p>If necessary to support even larger file systems, the cost of adding extra memory to the master is a small price to pay for the simplicity, reliability, performance, and flexibility we gain by storing the metadata in memory.</p>
<p>如果有必要支持更大的文件系统，在master中增加额外的内存相对于我们使用内存所带来的的灵活性和便捷性等优点来说，所付出的代价是很小的。</p>
<h4 id="2-6-2-Chunk-Locations"><a href="#2-6-2-Chunk-Locations" class="headerlink" title="2.6.2 Chunk Locations"></a>2.6.2 Chunk Locations</h4><p>2.6.2 块位置</p>
<p>The master does not keep a persistent record of which chunkservers have a replica of a given chunk. It simply polls chunkservers for that information at startup. The master can keep itself up-to-date thereafter because it controls all chunk placement and monitors chunkserver status with regular HeartBeat messages.</p>
<p>master不会持久的保存记录，记录哪些chunkservers有一个给定的块的副本。它只是在启动时对chunkservers进行轮询，以获取这些信息。主站可以在此后保持最新的状态，因为它控制着所有的chunkservers，并通过定期的心跳消息监控chunkserver的状态。</p>
<p>We initially attempted to keep chunk location information persistently at the master, but we decided that it was much simpler to request the data from chunkservers at startup, and periodically thereafter. This eliminated the problem of keeping the master and chunkservers in sync as chunkservers join and leave the cluster, change names, fail, restart, and so on. In a cluster with hundreds of servers, these events happen all too often.</p>
<p>我们最初试图在主站中持续保持chunkservers的位置信息，但我们决定在启动时从chunkservers那里请求数据，并在启动后定期请求。这样一来，当chunkservers加入和离开集群、更改名称、失败、重启等情况下，主服务器和chunkservers保持同步的问题就迎刃而解了。在一个有数百台服务器的集群中，这些事件经常发生。</p>
<p>Another way to understand this design decision is to realize that a chunkserver has the final word over what chunks it does or does not have on its own disks. There is no point in trying to maintain a consistent view of this information on the master because errors on a chunkserver may cause chunks to vanish spontaneously (e.g., a disk may go bad and be disabled) or an operator may rename a chunkserver.</p>
<p>理解这个设计决定的另一个方法是，要知道chunkserver对自己的磁盘上有或没有的chunks有最终决定权。试图在master上保持这些信息的一致性是没有意义的，因为chunkserver上的错误可能会导致chunks自动消失（例如，磁盘可能会坏掉并被禁用），或者操作者可能会重命名chunkserver。</p>
<h4 id="2-6-3-Operation-Log"><a href="#2-6-3-Operation-Log" class="headerlink" title="2.6.3 Operation Log"></a>2.6.3 Operation Log</h4><p>2.6.3 操作日志</p>
<p>The operation log contains a historical record of critical metadata changes. It is central to GFS. Not only is it the only persistent record of metadata, but it also serves as a logical time line that defines the order of concurrent operations. Files and chunks, as well as their versions (see Section 4.5), are all uniquely and eternally identified by the logical times at which they were created.</p>
<p>操作日志包含了关键元数据变化的历史记录。它是GFS的核心。它不仅是元数据的唯一持久记录，而且也是定义了并发操作顺序的逻辑时间线。文件和块，以及它们的版本（见第4.5节），都是由它们创建时的逻辑时间来唯一，永恒地识别。</p>
<p>Since the operation log is critical, we must store it reliably and not make changes visible to clients until metadata changes are made persistent. Otherwise, we effectively lose the whole file system or recent client operations even if the chunks themselves survive. Therefore, we replicate it on multiple remote machines and respond to a client operation only after flushing the corresponding log record to disk both locally and remotely. The master batches several log records together before flushing thereby reducing the impact of flushing and replication on overall system throughput.</p>
<p>由于操作日志非常关键，我们必须可靠地存储它，并且在元数据变化被持久化之前，不能让客户端看到变化。否则，即使块本身没有出现问题，我们也将丢失整个文件系统或最近的客户端操作。因此，我们将其复制到多个远程机器上，只有在本地和远程都将相应的日志记录刷新到磁盘后，才会对客户端操作做出响应。在写入之前，master会将多条日志记录合并在一起，从而减少写入和复制对整个系统吞吐量的影响。</p>
<p>The master recovers its file system state by replaying the operation log. To minimize startup time, we must keep the log small. The master checkpoints its state whenever the log grows beyond a certain size so that it can recover by loading the latest checkpoint from local disk and replaying only the limited number of log records after that. The checkpoint is in a compact B-tree like form that can be directly mapped into memory and used for namespace lookup without extra parsing. This further speeds up recovery and improves availability.</p>
<p>master通过回放操作日志来恢复其文件系统状态。为了尽量减少启动时间，我们必须保持日志的大小。每当日志增长到超过一定大小时，master就会对其状态进行checkpoint，这样，它就可以通过从本地磁盘加载最新的checkpoint来恢复，之后只回放有限的日志记录。该检查点采用了类似于B树的紧凑形式，可以直接映射到内存中，无需额外的解析就可以用于命名空间查找。这进一步加快了恢复速度，提高了可用性。</p>
<p>Because building a checkpoint can take a while, the master’s internal state is structured in such a way that a new checkpoint can be created without delaying incoming mutations. The master switches to a new log file and creates the new checkpoint in a separate thread. The new checkpoint includes all mutations before the switch. It can be created in a minute or so for a cluster with a few million files. When completed, it is written to disk both locally and remotely.</p>
<p>因为建立一个检checkpoint可能需要一段时间，所以master内部状态的结构是这样的，这样就可以在不延迟传入突变的情况下创建一个新的checkpoint。master会切换到一个新的日志文件，并在一个单独的线程中创建新的checkpoint。新的checkpoint包含了切换前的所有修改。对于一个有几百万个文件的集群，它可以在一分钟左右的时间内创建。完成后，它将被写到磁盘上，包括本地和远程。</p>
<p>Recovery needs only the latest complete checkpoint and subsequent log files. Older checkpoints and log files can be freely deleted, though we keep a few around to guard against catastrophes. A failure during checkpointing does not affect correctness because the recovery code detects and skips incomplete checkpoints.</p>
<p>恢复只需要最新的完整checkpoint和后续的日志文件。较旧的checkpoint和日志文件可以自由删除，不过我们会保留一些以防止灾难发生。在checkpoint期间发生的故障不会影响正确性，因为恢复代码会检测并跳过不完整的检查点。</p>
<hr>
<p> 未完待续！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/05/12/SQL-HackerRank-Weather-Observation-Station-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/12/SQL-HackerRank-Weather-Observation-Station-4/" class="post-title-link" itemprop="url">[SQL]HackerRank: Weather Observation Station 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-12 09:46:10" itemprop="dateCreated datePublished" datetime="2020-05-12T09:46:10+08:00">2020-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Let <code>N</code> be the number of CITY entries in STATION, and let <code>N&#39;</code> be the number of distinct CITY names in STATION; query the value of <code>N - N&#39;</code> from STATION. In other words, find the difference between the total number of CITY entries in the table and the number of distinct CITY entries in the table.</p>
<p><strong>Input Format</strong></p>
<p>The STATION table is described as follows:</p>
<p><img src="https://images.haishenming.xyz/blog/20200512094959.jpg"></p>
<p>where LAT_N is the northern latitude and LONG_W is the western longitude.</p>
<p><strong>题解</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(CITY) - <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> CITY) <span class="keyword">FROM</span> STATION;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/05/11/%E6%BA%AA%E5%B1%B1%E7%90%B4%E5%86%B52-%E4%B8%80%E6%9B%B0%E9%9D%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/%E6%BA%AA%E5%B1%B1%E7%90%B4%E5%86%B52-%E4%B8%80%E6%9B%B0%E9%9D%99/" class="post-title-link" itemprop="url">[溪山琴况2]一曰静</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-11 17:55:00" itemprop="dateCreated datePublished" datetime="2020-05-11T17:55:00+08:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BA%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">人文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>抚琴卜静处亦何难？独难于运指之静。然指动而求声，恶乎得静？余则曰，政在声中求静耳。</p>
<p>声厉则知指躁，声粗则知指浊，声希则知指静,此审音之道也。盖静由中出，声自心生，苟心有杂扰，手有物扰，以之抚琴，安能得静？惟涵养之士，淡泊宁静，心无尘翳，指有余闲，与论希声之理，悠然可得矣。</p>
<p>所谓希者，至静之极，通乎杳渺，出有入无，而游神于羲皇之上者也。约其下指工夫，一在调气，一在练指。调气则神自静，练指则音自静。如爇妙香者，含其烟而吐雾；涤岕茗者，荡其浊而泻清。</p>
<p>取静音者亦然，雪其躁气，释其竞心，指下扫尽炎嚣，弦上恰存贞洁。故虽急而不乱，多而不繁，渊深在中，清光发外，有道之士，当自得之。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/04/29/MIT-6-824-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F2-MapReduce-Simplified-Data-Processing-on-Large-Clusters-%E8%AF%91%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/29/MIT-6-824-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F2-MapReduce-Simplified-Data-Processing-on-Large-Clusters-%E8%AF%91%E6%96%87/" class="post-title-link" itemprop="url">[MIT-6.824-分布式系统2]译文MapReduce:大型集群上的简化数据处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-29 11:01:07" itemprop="dateCreated datePublished" datetime="2020-04-29T11:01:07+08:00">2020-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MIT的教学非常重视对经典论文的学习，比如在第一课开头就要求学习google于2004年发表的论文<code>MapReduce: Simplified Data Processing on Large Clusters</code>，原版是英文的，我在学习的同时也出一个翻译版。本人英语渣渣，翻译大部分借助<code>DeepL</code>这个工具，并稍加处理，哈哈。</p>
<p>论文地址： <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce: Simplified Data Processing on Large Clusters</a></p>
<p>下面是原文和译文：</p>
<blockquote>
<p>MapReduce: Simplified Data Processing on Large Clusters<br>MapReduce: 大型集群上的简化数据处理</p>
</blockquote>
<h3 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0 Abstract"></a>0 Abstract</h3><p>摘要</p>
<p>MapReduce is a programming model and an associ-ated implementation for processing and generating largedata sets.  Users specify a map function that processes akey/value pair to generate a set of intermediate key/valuepairs, and areducefunction that merges all intermediatevalues associated with the same intermediate key. Manyreal world tasks are expressible in this model, as shownin the paper.</p>
<p>MapReduce是一种编程模型和关联实现，用于处理和生成大数据集。 用户指定一个map函数，处理一个key/value对，生成一组中间key/value对，并指定一个reduce函数，合并所有与同一中间key相关联的中间值。许多现实世界的任务都可以在这个模型中表达，如本文所示。</p>
<p>Programs written in this functional style are automatically parallelized and executed on a large cluster of commodity machines. The run-time system takes care of the details of partitioning the input data, scheduling the program’s execution across a set of machines, handling machine failures, and managing the required inter-machine communication. This allows programmers without any experience with parallel and distributed systems to easily utilize the resources of a large distributed system.</p>
<p>用这种功能风格编写的程序会自动并行化，并在一个大型的商业机集群上执行。运行时系统负责对输入数据进行分区，在一组机器上调度程序的执行，处理机器故障，以及管理所需的机器间通信等细节。这使得没有任何并行和分布式系统经验的程序员可以轻松地利用大型分布式系统的资源。</p>
<p>Our implementation of MapReduce runs on a large cluster of commodity machines and is highly scalable: a typical MapReduce computation processes many terabytes of data on thousands of machines. Programmers find the system easy to use: hundreds of MapReduce programs have been implemented and upwards of one thousand MapReduce jobs are executed on Google’s clusters every day.</p>
<p>我们的MapReduce实现在大型商业机集群上运行，并且具有高度的可扩展性：一个典型的MapReduce计算在数千台机器上处理数以太记大小（太字节）的数据。程序员们发现这个系统很容易使用：我们已经实现了数百个MapReduce程序，每天在Google的集群上执行的MapReduce作业多达上千个。</p>
<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>1 简介</p>
<p>Over the past five years, the authors and many others at Google have implemented hundreds of special-purpose computations that process large amounts of raw data, such as crawled documents, web request logs, etc., to compute various kinds of derived data, such as inverted indices, various representations of the graph structure of web documents, summaries of the number of pages crawled per host, the set of most frequent queries in a given day, etc. Most such computations are conceptually straightforward. However, the input data is usually large and the computations have to be distributed across hundreds or thousands of machines in order to finish in a reasonable amount of time. The issues of how to parallelize the computation, distribute the data, and handle failures conspire to obscure the original simple computation with large amounts of complex code to deal with these issues.</p>
<p>在过去的五年里，作者和Google的许多人已经实现了数百种特殊用途的计算，这些计算处理了大量的原始数据，如抓取的文档、网络请求日志等，以计算出各种衍生数据，如倒置指数、网络文档图结构的各种表示、每个主机抓取的页面数的汇总、给定的一天中最频繁的查询集等。大多数这样的计算在概念上都很简单。然而，输入的数据通常很大，计算必须分布在数百或数千台机器上，才能在合理的时间内完成。如何并行化计算、分发数据、处理故障等问题，而要处理这些问题，就需要用大量的复杂代码来解决。</p>
<p>As a reaction to this complexity, we designed a new abstraction that allows us to express the simple computations we were trying to perform but hides the messy details of parallelization, fault-tolerance, data distribution and load balancing in a library. Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages. We realized that most of our computations involved applying a map operation to each logical “record” in our input in order to compute a set of intermediate key/value pairs, and then applying a reduce operation to all the values that shared the same key, in order to combine the derived data appropriately. Our use of a functional model with userspecified map and reduce operations allows us to paral- lelize large computations easily and to use re-execution as the primary mechanism for fault tolerance.</p>
<p>作为对这种复杂性的一种反应，我们设计了一种新的抽象，它允许我们表达我们试图执行的简单计算，但在库中隐藏了并行化、容错、数据分配和负载均衡等杂乱的细节。我们的抽象是受Lisp和许多其他功能语言中的map和reduce原语的启发。我们意识到，我们的大部分计算都涉及到对输入中的每一条逻辑应用一个map操作，以计算出一组中间的key/value对，然后对所有共享相同key的值应用一个reduce操作，以适当地组合出的数据。我们使用了一个功能模型，通过用户指定的映射和还原操作，使我们能够轻松地将大型计算进行分析，并将重新执行作为主要的容错机制。</p>
<p>The major contributions of this work are a simple and powerful interface that enables automatic parallelization and distribution of large-scale computations, combined with an implementation of this interface that achieves high performance on large clusters of commodity PCs.</p>
<p>这项工作的主要贡献在于提供了一个简单而强大的接口，可以实现大规模计算的自动并行化和分布式计算，结合该接口的实现，在大型商业计算机集群上实现了高性能。</p>
<p>Section 2 describes the basic programming model and gives several examples. Section 3 describes an implementation of the MapReduce interface tailored towards our cluster-based computing environment. Section 4 describes several refinements of the programming model that we have found useful. Section 5 has performance measurements of our implementation for a variety of tasks. Section 6 explores the use of MapReduce within Google including our experiences in using it as the basis for a rewrite of our production indexing system. Section 7 discusses related and future work.</p>
<p>第2节介绍了基本的编程模型，并给出了几个例子。第3节描述了一个针对我们基于集群计算环境的MapReduce接口的实现。第4节描述了我们发现有用的几个编程模型的改进。第5节介绍了我们对各种任务的性能测试。第6节探讨了 MapReduce 在 Google 中的应用，包括我们使用它重写生产索引系统的一些经验。第7节讨论了相关的以及今后的发展。</p>
<h3 id="2-Programming-Model"><a href="#2-Programming-Model" class="headerlink" title="2 Programming Model"></a>2 Programming Model</h3><p>2 编程模型</p>
<p>The computation takes a set of input key/value pairs, and produces a set of output key/value pairs. The user of the MapReduce library expresses the computation as two functions: Map and Reduce.</p>
<p>计算取一组输入key/value对，并产生一组输出key/value对。MapReduce库的用户将计算表达为两个函数，Map和Reduce。</p>
<p>Map, written by the user, takes an input pair and produces a set of intermediate key/value pairs. The MapReduce library groups together all intermediate values associated with the same intermediate key I and passes them to the Reduce function.</p>
<p>Map，由用户编写，获取一个输入对并产生一组中间键/值对。MapReduce库将所有与同一中间键I相关联的中间值分组，并将其传递给Reduce函数。</p>
<p>The Reduce function, also written by the user, accepts an intermediate key I and a set of values for that key. It merges together these values to form a possibly smaller set of values. Typically just zero or one output value is produced per Reduce invocation. The intermediate values are supplied to the user’s reduce function via an iterator. This allows us to handle lists of values that are too large to fit in memory.</p>
<p>Reduce函数也是由用户编写的，它接受一个中间键I和该键的一组值。它将这些值合并在一起，形成一个可能更小的值集。通常情况下，每次调用Reduce函数只产生0或一个输出值。中间值通过迭代器提供给用户的Reduce函数。这样我们就可以处理那些太大的值列表，而这些值太大，无法放入内存中。</p>
<h4 id="2-1-Example"><a href="#2-1-Example" class="headerlink" title="2.1 Example"></a>2.1 Example</h4><p>2.1 实例</p>
<p>Consider the problem of counting the number of occurrences of each word in a large collection of documents. The user would write code similar to the follow- ing pseudo-code:</p>
<p>考虑一下在大量文档中计算每个单词的出现次数的问题。用户将编写类似于下面的伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(String key, String value):</span><br><span class="line">  <span class="comment">// key: document name</span></span><br><span class="line">  <span class="comment">// value: document contents</span></span><br><span class="line">  <span class="keyword">for</span> each word w in value:</span><br><span class="line">    EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">  <span class="comment">// key: a word</span></span><br><span class="line">  <span class="comment">// values: a list of counts</span></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> each v in values:</span><br><span class="line">    result += ParseInt(v);</span><br><span class="line">  Emit(AsString(result));</span><br></pre></td></tr></table></figure>

<p>The map function emits each word plus an associated count of occurrences (just ‘1’ in this simple example). The reduce function sums together all counts emitted for a particular word.</p>
<p>map函数返回每个单词加上一个它出现的次数（在这个简单的例子中只是’1’）。reduce函数将一个特定单词的所有计数相加。</p>
<p>In addition, the user writes code to fill in a mapreduce specification object with the names of the input and output files, and optional tuning parameters. The user then invokes the MapReduce function, passing it the specification object. The user’s code is linked together with the MapReduce library (implemented in C++). Appendix A contains the full program text for this example.</p>
<p>此外，用户编写代码来实现一个符合Mapreduce规范的对象，其中包含输入和输出文件的名称，以及可选的调优参数。然后用户调用MapReduce函数，将对象传递给它。用户的代码与MapReduce库（用C++实现）连接在一起。附录A包含了这个例子的完整程序文本。</p>
<h4 id="2-2-Types"><a href="#2-2-Types" class="headerlink" title="2.2 Types"></a>2.2 Types</h4><p>2.2 类型</p>
<p>Even though the previous pseudo-code is written in terms of string inputs and outputs, conceptually the map and reduce functions supplied by the user have associated types:</p>
<p>尽管前面的伪代码是用字符串输入和输出来写的，但从概念上讲，用户提供的map函数和reduce函数都有关联类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> (k1,v1) → <span class="built_in">list</span>(k2,v2)</span><br><span class="line"></span><br><span class="line">reduce (k2,<span class="built_in">list</span>(v2))  → <span class="built_in">list</span>(v2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>I.e., the input keys and values are drawn from a different domain than the output keys and values. Furthermore, the intermediate keys and values are from the same domain as the output keys and values.</p>
<p>也就是说，输入键与输出键和值均来自不同的域。此外，中间的键和值与输出的键和值来自同一个域。</p>
<p>Our C++ implementation passes strings to and from the user-defined functions and leaves it to the user code to convert between strings and appropriate types.</p>
<p>我们的C++实现将字符串传递给用户定义的函数，然后由用户代码在字符串和适当类型之间进行转换。</p>
<h4 id="2-3-More-Examples"><a href="#2-3-More-Examples" class="headerlink" title="2.3 More Examples"></a>2.3 More Examples</h4><p>2.3 更多的实例</p>
<p>Here are a few simple examples of interesting programs that can be easily expressed as MapReduce computations.</p>
<p>这里有几个简单的例子，可以很容易地表示为MapReduce计算的有趣程序。</p>
<p><strong>Distributed Grep</strong>: The map function emits a line if it matches a supplied pattern. The reduce function is an identity function that just copies the supplied intermedi- ate data to the output.</p>
<p><strong>Distributed Grep</strong>: map函数如果匹配了所提供的模式，就会发出一条线。reduce函数是一个身份函数，它只是将提供的中间数据复制到输出端。</p>
<p><strong>Count of URL Access Frequency</strong>: The map func- tion processes logs of web page requests and outputs ⟨URL, 1⟩. The reduce function adds together all values for the same URL and emits a ⟨URL, total count⟩ pair.</p>
<p><strong>Count of URL Access Frequency</strong>：map函数处理网页请求的日志，并输出⟨URL，1⟩。reduce函数将同一URL的所有值相加，并输出一个⟨URL, total count⟩对。</p>
<p><strong>Reverse Web-Link Graph</strong>: The map function outputs ⟨target,source⟩ pairs for each link to a target URL found in a page named source. The reduce function concatenates the list of all source URLs associated with a given target URL and emits the pair:⟨target, list(source)⟩</p>
<p><strong>Reverse Web-Link Graph</strong>: map函数为每一个链接到source的页面中的目标URL输出⟨target,source⟩对。reduce函数将所有与给定目标URL相关联的源URL的列表串联起来，然后输出对：⟨target, list(source)⟩</p>
<p><strong>Inverted Index</strong>: The map function parses each document, and emits a sequence of ⟨word, document ID⟩ pairs. The reduce function accepts all pairs for a given word, sorts the corresponding document IDs and emits a ⟨word,list(document ID)⟩pair.These to fallout put pairs forms a simple inverted index. It is easy to augment this computation to keep track of word positions.</p>
<p><strong>Inverted Index</strong>: map函数解析每个文档，并发出一系列的⟨word, document ID⟩对。reduce函数接受给定单词的所有词对，对相应的文档ID进行排序，并发出一个⟨word,list(document ID)⟩对。这些word对的倒置对形成一个简单的倒置索引。可以很容易地增强这种计算来跟踪单词的位置。</p>
<p><strong>Distributed Sort</strong>: The map function extracts the key from each record, and emits a ⟨key, record⟩ pair. The reduce function emits all pairs unchanged. This computation depends on the partitioning facilities described in Section 4.1 and the ordering properties described in Section 4.2.</p>
<p><strong>Distributed Sort</strong>: map函数从每条记录中提取关键字，并发出一个⟨key，record⟩对。而 reduce 函数则是以同样的方式输出所有的数据对。这种计算取决于第4.1节中描述的分区设施和第4.2节中描述的排序属性。</p>
<h3 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3 Implementation"></a>3 Implementation</h3><p>3 实现</p>
<p>Many different implementations of the MapReduce interface are possible. The right choice depends on the environment. For example, one implementation may be suitable for a small shared-memory machine, another for a large NUMA multi-processor, and yet another for an even larger collection of networked machines.</p>
<p>MapReduce接口有许多不同的实现方式。正确的选择取决于环境的不同。例如，一种实现可能适用于小型共享内存机，另一种实现适用于大型NUMA多处理器的机器，而另一种则适用于更大的网络化集群。</p>
<p>This section describes an implementation targeted to the computing environment in wide use at Google:large clusters of commodity PCs connected together with switched Ethernet. In our environment:</p>
<p>本节介绍一种针对Google广泛使用的计算环境的实现：用交换式以太网连接在一起的大型商业计算机集群。在我们的环境中：</p>
<p>(1) Machines are typically dual-processor x86 processors running Linux, with 2-4 GB of memory per machine.</p>
<p>(1）机器一般是运行Linux的双核x86处理器，每台机器的内存为2-4GB。</p>
<p>(2) Commodity networking hardware is used - typically either 100 megabits/second or 1 gigabit/second at the machine level, but averaging considerably less in over- all bisection bandwidth.</p>
<p>(2) 使用的是商用网络硬件—-通常是100兆/秒或1千兆/秒，但在所有的分段带宽中，平均下来要少得多。</p>
<p>(3) A cluster consists of hundreds or thousands of machines, and therefore machine failures are common.</p>
<p>(3)一个集群由成百上千台机器组成，因此机器故障是很常见的。</p>
<p>(4) Storage is provided by inexpensive IDE disks attached directly to individual machines. A distributed file system developed in-house is used to manage the data stored on these disks. The file system uses replication to provide availability and reliability on top of unreliable hardware.</p>
<p>(4)存储由直接连接到各个机器上的廉价的IDE磁盘提供。一个内部开发的分布式文件系统（GFS）被用来管理存储在这些磁盘上的数据。该文件系统使用复制机制，在的硬件之上提供可用性和可靠性。</p>
<p>(5) Users submit jobs to a scheduling system. Each job consists of a set of tasks, and is mapped by the scheduler to a set of available machines within a cluster.</p>
<p>5）用户向调度系统提交作业。每个作业由一组任务组成，由调度员将其映射到群集内的一组可用机器上。</p>
<h4 id="3-1-Execution-Overview"><a href="#3-1-Execution-Overview" class="headerlink" title="3.1 Execution Overview"></a>3.1 Execution Overview</h4><p>3.1 运行概述</p>
<p>The Map invocations are distributed across multiple machines by automatically partitioning the input data into a set of M splits. The input splits can be pro- cessed in parallel by different machines. Reduce invocations are distributed by partitioning the intermediate key space into R pieces using a partitioning function (e.g., hash(key) mod R). The number of partitions (R) and the partitioning function are specified by the user.</p>
<p>通过将输入数据自动分割成每组M个分片，Map调用被分布在多台机器上。这些输入的分割可以由不同的机器并行进行。Reduce调用是通过使用分区函数（例如，hash(key) mod R）将中间密钥空间分割成R块来进行处理。分区的数量(R)和分区函数由用户指定。</p>
<p>Figure 1 shows the overall flow of a MapReduce operation in our implementation. When the user program calls the MapReduce function, the following sequence of actions occurs (the numbered labels in Figure 1 correspond to the numbers in the list below):</p>
<p>图1显示了我们实现中MapReduce操作的整体流程。当用户程序调用MapReduce函数时，会发生以下的操作顺序（图1中的数字标签对应于下面列表中的数字）。</p>
<p><img src="https://images.haishenming.xyz/blog/Figure1.png" alt="Figure1"></p>
<p>1.The MapReduce library in the user program first splits the input files into M pieces of typically 16 megabytes to 64 megabytes (MB) per piece (controllable by the user via an optional parameter). It then starts up many copies of the program on a cluster of machines.</p>
<p>1.用户程序中的 MapReduce 库首先将输入文件分成 M 个片段，每个片段通常为 16 兆到 64 兆（可由用户通过一个可选的参数控制）。然后，它在一个机器集群上启动了许多程序的副本。</p>
<p>2.One of the copies of the program is special – the master. The rest are workers that are assigned work by the master. There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.</p>
<p>2.程序中的副本有一个是特殊的副本–master。其余的都是由master分配工作的worker。有M个map任务和R个reduce任务。master挑选闲置的worker，给每个worker分配一个map任务或reduce任务。</p>
<p>3.A worker who is assigned a map task reads the contents of the corresponding input split. It parses key/value pairs out of the input data and passes each pair to the user-defined Map function. The intermediate key/value pairs produced by the Map function are buffered in memory.</p>
<p>3.一个被分配到map任务的woker会读取相应的被分割内容。它解析输入数据中的键/值对，并将每个键/值对传递给用户定义的Map函数。由map函数产生的中间键/值将对被缓冲在内存中。</p>
<p>4.Periodically, the buffered pairs are written to local disk, partitioned into R regions by the partitioning function. The locations of these buffered pairs on the local disk are passed back to the master, who is responsible for forwarding these locations to the reduce workers.</p>
<p>4.定期将缓冲对写到本地磁盘上，通过分区函数将这些缓冲对写到本地磁盘上，由分区函数将其划分为R区域。这些缓冲对在本地磁盘上的位置被传回给master，由master负责将这些位置转发到运行reduce函数的worker上。</p>
<p>5.When a reduce worker is notified by the master about these locations, it uses remote procedure calls to read the buffered data from the local disks of the map workers. When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so that all occurrences of the same key are grouped together. The sorting is needed because typically many different keys map to the same reduce task. If the amount of intermediate data is too large to fit in memory, an external sort is used.</p>
<p>5.当一个reduce worker接收到master的通知后，它使用远程过程调用从map worker的本地磁盘读取缓冲数据。当一个reduce worker读取了所有的中间数据后，它会根据中间键对其进行排序，以便将同一键的所有出现的数据分组。这种排序是必要的，因为通常情况下，许多不同的键会映射到同一个reduce任务中。如果中间数据量太大，无法容纳在内存中，则使用外部排序。</p>
<p>6.The reduce worker iterates over the sorted intermediate data and for each unique intermediate key encountered, it passes the key and the corresponding set of intermediate values to the user’s Reduce function. The output of the Reduce function is appended to a final output file for this reduce partition.</p>
<p>6.Reduce Worker会对排序后的中间数据进行迭代，对于每一个唯一的中间键，它将key和相应的中间值集传递给用户的Reduce函数。Reduce函数的输出被附加到这个Reduce分区的最终输出文件中。</p>
<p>7.When all map tasks and reduce tasks have been completed, the master wakes up the user program. At this point, the MapReduce call in the user program returns back to the user code.</p>
<p>7.当所有的map任务和reduce任务完成后，master序唤醒用户程序。此时，用户程序中的MapReduce调用结束。</p>
<p>After successful completion, the output of the mapreduce execution is available in the R output files (one per reduce task, with file names as specified by the user). Typically, users do not need to combine these R output files into one file – they often pass these files as input to another MapReduce call, or use them from another distributed application that is able to deal with input that is partitioned into multiple files.</p>
<p>成功完成后，mapreduce执行的输出可以在R输出文件中得到（每个reduce任务一个，文件名由用户指定）。通常情况下，用户不需要将这些R输出文件合并成一个文件–他们通常会将这些文件作为输入传递给另一个MapReduce调用，或者从另一个能够处理被分割成多个文件的输入的分布式应用中使用。</p>
<h4 id="3-2-Master-Data-Structures"><a href="#3-2-Master-Data-Structures" class="headerlink" title="3.2 Master Data Structures"></a>3.2 Master Data Structures</h4><p>3.2 master 数据结构</p>
<p>The master keeps several data structures. For each map task and reduce task, it stores the state (idle, in-progress, or completed), and the identity of the worker machine (for non-idle tasks).</p>
<p>master保存了几个数据结构。对于每个map任务和reduce任务，master将存储它们的状态（空闲、正在进行中或已完成），以及worker机器的ID（对于非空闲任务）。</p>
<p>The master is the conduit through which the location of intermediate file regions is propagated from map tasks to reduce tasks. Therefore, for each completed map task, the master stores the locations and sizes of the R intermediate file regions produced by the map task. Updates to this location and size information are received as map tasks are completed. The information is pushed incrementally to workers that have in-progress reduce tasks.</p>
<p>master是将中间文件区的位置从map任务传播到reduce任务的通道。因此，对于每个完成的map任务，master会存储由map任务产生的R个中间文件区域的位置和大小。随着map任务的完成，master会接收到这个位置和大小信息的更新。这些信息会递增地推送给有正在进行中的reduce任务的worker。</p>
<h4 id="3-3-Fault-Tolerance"><a href="#3-3-Fault-Tolerance" class="headerlink" title="3.3 Fault Tolerance"></a>3.3 Fault Tolerance</h4><p>3.3 容错</p>
<p>Since the MapReduce library is designed to help process very large amounts of data using hundreds or thousands of machines, the library must tolerate machine failures gracefully.</p>
<p>由于MapReduce库是为辅助使用成百上千台机器处理大量的数据而设计的，因此该库必须能优雅地处理机器故障。</p>
<p><strong>Worker Failure</strong></p>
<p>worker故障</p>
<p>The master pings every worker periodically. If no response is received from a worker in a certain amount of time, the master marks the worker as failed. Any map tasks completed by the worker are reset back to their initial idle state, and therefore become eligible for scheduling on other workers. Similarly, any map task or reduce task in progress on a failed worker is also reset to idle and becomes eligible for rescheduling.</p>
<p>master会定期ping一下每个worker。如果在一定的时间内没有收到worker的回复，master会将该工人标记为failed。任何由该worker完成的map任务都会被重置为初始空闲状态，因此可以在其他worker上进行调度。同样的，失败的worker上的任何map任务或正在进行中的reduce任务也会被重置为空闲状态，并可以被重新安排。</p>
<p>Completed map tasks are re-executed on a failure be- cause their output is stored on the local disk(s) of the failed machine and is therefore inaccessible. Completed reduce tasks do not need to be re-executed since their output is stored in a global file system.</p>
<p>已完成的reduce任务在失败时被重新执行，因为它们的输出存储在失败的机器的本地磁盘上，因此无法访问。已完成的reduce任务不需要重新执行，因为它们的输出存储在全局文件系统中。</p>
<p>When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the reexecution. Any reduce task that has not already read the data from worker A will read the data from worker B.</p>
<p>当一个map任务先由worker A执行，然后由woker B执行（因为A失败），所有执行reduce任务的worker都会被通知重新执行。任何还没有从worker A读取数据的reduce任务都将从worker B读取数据。</p>
<p>MapReduce is resilient to large-scale worker failures. For example, during one MapReduce operation, network maintenance on a running cluster was causing groups of 80 machines at a time to become unreachable for several minutes. The MapReduce master simply re-executed the work done by the unreachable worker machines, and continued to make forward progress, eventually completing the MapReduce operation.</p>
<p>MapReduce能够应对大规模的worker故障。例如，在一次MapReduce操作过程中，一个正在运行的集群上的网络维护导致一次80台机器群组在数分钟内无法访问。MapReduce master简单地重新执行了无法到达的worker机器所做的工作，并继续向前推进，最终完成了MapReduce操作。</p>
<p><strong>Master Failure</strong></p>
<p>master 故障</p>
<p>It is easy to make the master write periodic checkpoints of the master data structures described above. If the master task dies, a new copy can be started from the last checkpointed state. However, given that there is only a single master, its failure is unlikely; therefore our current implementation aborts the MapReduce computation if the master fails. Clients can check for this condition and retry the MapReduce operation if they desire.</p>
<p>一个简单的解决好办法就是让master周期性的将上文所描述的数据结构写入磁盘。如果master死了，可以从最后一个检查点状态开始新的拷贝。然而，考虑到只有一个master，它的失败可能性不大；因此，我们目前的实现在master失败的情况下，会中止MapReduce计算。客户端可以检查这个条件，如果他们愿意，可以重新尝试MapReduce操作。</p>
<p><strong>Semantics in the Presence of Failures</strong></p>
<p>失败情况下的语义</p>
<p>When the user-supplied map and reduce operators are deterministic functions of their input values, our distributed implementation produces the same output as would have been produced by a non-faulting sequential execution of the entire program.</p>
<p>当用户提供的map和reduce算子是其输入值的决定性函数时，我们的分布式实现所产生的输出与整个程序的正常顺序执行所产生的输出相同。</p>
<p>We rely on atomic commits of map and reduce task outputs to achieve this property. Each in-progress task writes its output to private temporary files. A reduce task produces one such file, and a map task produces R such files (one per reduce task). When a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message. If the master receives a completion message for an already completed map task, it ignores the message. Otherwise, it records the names of R files in a master data structure.</p>
<p>我们依靠map和reduce任务输出的原子性提交来实现这个属性。每个进行中的任务都会将其输出写入私有的临时文件。每个reduce任务都会产生一个这样的文件，而每个map任务会产生R个这样的文件（每个reduce任务一个）。当一个map任务完成时，worker会向master发送一个消息，并在消息中包含R个临时文件的名称。如果master收到一个map任务的完成消息，它将忽略该消息。否则，它将在master中记录R文件的名称。</p>
<p>When a reduce task completes, the reduce worker atomically renames its temporary output file to the final output file. If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file. We rely on the atomic rename operation provided by the underlying file system to guarantee that the final file system state contains just the data produced by one execution of the reduce task.</p>
<p>当一个reduce任务完成后，reduce worker会将其临时输出文件原子化地重命名为最终输出文件。如果同一个reduce任务在多台机器上执行，那么同一个最终输出文件将被执行多次重命名调用。我们依靠底层文件系统提供的原子重命名操作来保证最终文件系统状态只包含一个reduce任务的执行所产生的数据。</p>
<p>The vast majority of our map and reduce operators are deterministic, and the fact that our semantics are equivalent to a sequential execution in this case makes it very easy for programmers to reason about their program’s behavior. When the map and/or reduce operators are nondeterministic, we provide weaker but still reasonable semantics. In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program. However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.</p>
<p>我们的map和reduce运算符绝大多数都是确定性，而我们的语义在这种情况下相当于顺序执行，这使得程序员很容易理解程序的行为。当map和/或reduce算子不是确定的时候，我们提供的语义更弱，但仍然合理。在存在非确定性算子的情况下，一个特定的reduce任务R1的输出相当于非确定性程序的顺序执行所产生的输出。然而，另一个不同的reduce任务R2的输出可能对应于不同的非确定性程序的顺序执行所产生的R2的输出。</p>
<p>Consider map task M and reduce tasks R1 and R2. Let e(Ri) be the execution of Ri that committed (there is exactly one such execution). The weaker semantics arise because e(R1) may have read the output produced by one execution of M and e(R2) may have read the output produced by a different execution of M .</p>
<p>考虑map任务M和reduce任务R1和R2。0️令e(Ri)是Ri所提交的执行(正好有一个这样的执行)。较弱的语义产生了，因为e(R1)可能读取了M的一个执行所产生的输出，而e(R2)可能读取了M的另一个执行所产生的输出。</p>
<h4 id="3-4-Locality"><a href="#3-4-Locality" class="headerlink" title="3.4 Locality"></a>3.4 Locality</h4><p>3.4 地区性</p>
<p>Network bandwidth is a relatively scarce resource in our computing environment. We conserve network band- width by taking advantage of the fact that the input data (managed by GFS [8]) is stored on the local disks of the machines that make up our cluster. GFS divides each file into 64 MB blocks, and stores several copies of each block (typically 3 copies) on different machines. The MapReduce master takes the location information of the input files into account and attempts to schedule a map task on a machine that contains a replica of the corresponding input data. Failing that, it attempts to schedule a map task near a replica of that task’s input data (e.g., on a worker machine that is on the same network switch as the machine containing the data). When running large MapReduce operations on a significant fraction of the workers in a cluster, most input data is read locally and consumes no network bandwidth.</p>
<p>在我们的计算环境中，网络带宽是一个相对稀缺的资源。我们利用输入数据（由GFS管理）存储在组成我们集群的机器的本地磁盘上，从而节省了网络带宽。GFS将每个文件分成64MB的块，并将每个块的多个副本（通常是3个副本）存储在不同的机器上。MapReduce master会考虑到输入文件的位置信息，并尝试在包含相关输入数据副本的机器上分配一个map任务。如果失败，它将尝试在该任务的输入数据的副本附近安排一个map任务（例如，在与包含数据的机器处于同一网络交换机上的工作机上）。当在集群中的相当一部分worker上运行大型MapReduce操作时，大部分输入数据都是在本地读取，不消耗网络带宽。</p>
<h4 id="3-5-Task-Granularity"><a href="#3-5-Task-Granularity" class="headerlink" title="3.5 Task Granularity"></a>3.5 Task Granularity</h4><p>3.5 任务粒度</p>
<p>We subdivide the map phase into M pieces and the reduce phase into R pieces, as described above. Ideally, M and R should be much larger than the number of worker machines. Having each worker perform many different tasks improves dynamic load balancing, and also speeds up recovery when a worker fails: the many map tasks it has completed can be spread out across all the other worker machines.</p>
<p>如上所述，我们将map阶段细分为M个片，将reduce阶段细分为R个片。理想情况下，M和R应该比worker的数量大得多。让每个worker执行许多不同的任务，可以改善动态负载平衡，也可以在worker故障时加快恢复速度：它完成的许多map任务可以分散到所有其他worker上。</p>
<p>There are practical bounds on how large M and R can be in our implementation, since the master must make O(M + R) scheduling decisions and keeps O(M ∗ R) state in memory as described above. (The constant factors for memory usage are small however: the O(M ∗ R) piece of the state consists of approximately one byte of data per map task/reduce task pair.)</p>
<p>在我们的实现中，M和R可以有一定的实际限制，因为主站必须做出O(M+R)的调度决策，并在内存中保持O(M∗R)状态，如上所述。(然而，内存使用的常数因素很小：状态的O(M∗ R)部分大约由每个map/reduce任务对的数据一个字节组成)。</p>
<p>Furthermore, R is often constrained by users because the output of each reduce task ends up in a separate output file. In practice, we tend to choose M so that each individual task is roughly 16 MB to 64 MB of input data (so that the locality optimization described above is most effective), and we make R a small multiple of the number of worker machines we expect to use. We often perform MapReduce computations with M = 200, 000 and R = 5, 000, using 2,000 worker machines.</p>
<p>此外，R值通常会受到用户的限制，因为每个reduce任务的输出最终都会在一个单独的输出文件中。在实践中，我们倾向于选择合适的M值，使每个独立任务的输入数据量大致为16MB到64MB（这样，上面描述的定位优化最有效），并且我们使R值为预期使用的worker数量的小倍数。我们经常在M=200000，R=5000的情况下执行MapReduce计算，使用2000个worker。</p>
<h4 id="3-6-Backup-Tasks"><a href="#3-6-Backup-Tasks" class="headerlink" title="3.6 Backup Tasks"></a>3.6 Backup Tasks</h4><p>3.6 备用任务</p>
<p>One of the common causes that lengthens the total time taken for a MapReduce operation is a “straggler”: a machine that takes an unusually long time to complete one of the last few map or reduce tasks in the computation. Stragglers can arise for a whole host of reasons. For example, a machine with a bad disk may experience frequent correctable errors that slow its read performance from 30 MB/s to 1 MB/s. The cluster scheduling system may have scheduled other tasks on the machine, causing it to execute the MapReduce code more slowly due to competition for CPU, memory, local disk, or network bandwidth. A recent problem we experienced was a bug in machine initialization code that caused processor caches to be disabled: computations on affected machines slowed down by over a factor of one hundred.</p>
<p>加长MapReduce操作的总时间的常见原因之一是 “滞留者”：在计算中完成最后几个map或reduce任务中的一个任务需要异常长的时间。”滞留者”的出现有很多原因。例如，一个磁盘不好的机器可能会经常出现纠错行为，使其读取性能从30MB/s减慢到1MB/s。集群调度系统可能在机器上安排了其他任务，导致机器由于对CPU、内存、本地磁盘或网络带宽的竞争而导致MapReduce代码的执行速度更慢。我们最近遇到的一个问题是机器初始化代码中的一个错误，导致处理器缓存被禁用：受影响机器上的计算速度降低了一百倍以上。</p>
<p>We have a general mechanism to alleviate the problem of stragglers. When a MapReduce operation is close to completion, the master schedules backup executions of the remaining in-progress tasks. The task is marked as completed whenever either the primary or the backup execution completes. We have tuned this mechanism so that it typically increases the computational resources used by the operation by no more than a few percent. We have found that this significantly reduces the time to complete large MapReduce operations. As an example, the sort program described in Section 5.3 takes 44% longer to complete when the backup task mechanism is disabled.</p>
<p>我们有一个通用的机制来缓解滞留问题。当一个MapReduce操作快完成时，msater会对剩余的进行中任务进行备份执行。每当主任务或备份执行完成时，该任务就被标记为已完成。我们对这种机制进行了调整，使其通常会使操作所使用的计算资源增加不超过百分之几。我们发现，这大大减少了完成大型 MapReduce 操作的时间。作为一个例子，在5.3节描述的排序程序中，当备份任务机制被禁用时，完成该程序需要多花44%的时间。</p>
<h3 id="4-Refinements"><a href="#4-Refinements" class="headerlink" title="4 Refinements"></a>4 Refinements</h3><p>4 扩展细节</p>
<p>Although the basic functionality provided by simply writing Map and Reduce functions is sufficient for most needs, we have found a few extensions useful. These are described in this section.</p>
<p>虽然简单地编写Map和Reduce函数所提供的基本功能已经足够满足大多数需求，但我们发现有一些扩展是有用的。本节将对这些功能进行描述。</p>
<h4 id="4-1-Partitioning-Function"><a href="#4-1-Partitioning-Function" class="headerlink" title="4.1 Partitioning Function"></a>4.1 Partitioning Function</h4><p>4.1 分区函数</p>
<p>The users of MapReduce specify the number of reduce tasks/output files that they desire (R). Data gets partitioned across these tasks using a partitioning function on the intermediate key. A default partitioning function is provided that uses hashing (e.g. “hash(key) mod R”). This tends to result in fairly well-balanced partitions. In some cases, however, it is useful to partition data by some other function of the key. For example, sometimes the output keys are URLs, and we want all entries for a single host to end up in the same output file. To support situations like this, the user of the MapReduce library can provide a special partitioning function. For example, using “hash(Hostname(urlkey)) mod R” as the partitioning function causes all URLs from the same host to end up in the same output file.</p>
<p>MapReduce 的用户可以指定他们想要的reduce任务或输出文件的数量（R）。数据会在这些任务中使用分区函数以中间键的形式对数据进行分区。默认提供了一个使用hash的默认分区函数（例如：”hash(key) mod R”）。这往往会产生相当平均的分区。然而，在某些情况下，通过key的其他函数对数据进行分区是很有用的。例如，有时输出的key是URL，而我们希望一台设备的所有条目最终都在同一个输出文件中。为了支持这样的情况，MapReduce库的用户可以提供一个特殊的分区函数。例如，使用 “hash(Hostname(urlkey))mod R “作为分区函数，会导致同一设备的所有URL最终出现在同一个输出文件中。</p>
<h4 id="4-2-Ordering-Guarantees"><a href="#4-2-Ordering-Guarantees" class="headerlink" title="4.2 Ordering Guarantees"></a>4.2 Ordering Guarantees</h4><p>4.2 排序保证</p>
<p>We guarantee that within a given partition, the intermediate key/value pairs are processed in increasing key order. This ordering guarantee makes it easy to generate a sorted output file per partition, which is useful when the output file format needs to support efficient random access lookups by key, or users of the output find it convenient to have the data sorted.</p>
<p>我们保证在一个给定的分区内，中间的键/值对是按照递增的键顺序处理的。这种排序保证使得我们可以很容易地在每个分区中生成一个排序的输出文件，当输出文件格式需要支持按键进行有效的随机访问查找时，或者输出的用户发现数据排序很方便时，这种排序保证是非常有用的。</p>
<h4 id="4-2-Combiner-Function"><a href="#4-2-Combiner-Function" class="headerlink" title="4.2 Combiner Function"></a>4.2 Combiner Function</h4><p>4.2 Combiner函数</p>
<p>In some cases, there is significant repetition in the inter- mediate keys produced by each map task, and the userspecified Reduce function is commutative and associative. A good example of this is the word counting example in Section 2.1. Since word frequencies tend to follow a Zipf distribution, each map task will produce hundreds or thousands of records of the form &lt;the, 1&gt;. All of these counts will be sent over the network to a single reduce task and then added together by the Reduce function to produce one number. We allow the user to specify an optional Combiner function that does partial merging of this data before it is sent over the network.</p>
<p>在某些情况下，每个map任务产生的中间键都有明显的重复，用户指定的Reduce函数具备交换性和关联性。这方面的一个很好的例子是2.1节中的单词计数例子。由于单词频率倾向于遵循Zipf分布，因此每个map任务将产生数百或数千条&lt;the, 1&gt;形式的记录。所有这些计数都将通过网络发送到一个单一的Reduce任务，然后由Reduce函数相加，产生一个数字。我们允许用户指定一个可选的Combiner函数，在这些数据被发送到网络上之前，对这些数据进行部分合并。</p>
<p>The Combiner function is executed on each machine that performs a map task. Typically the same code is used to implement both the combiner and the reduce functions. The only difference between a reduce function and a combiner function is how the MapReduce library handles the output of the function. The output of a reduce function is written to the final output file. The output of a combiner function is written to an intermediate file that will be sent to a reduce task.</p>
<p>Combiner函数在每个执行map任务的机器上执行。通常情况下，Combiner函数和reduce函数都使用相同的代码来实现。reduce函数和Combiner函数之间的唯一区别是MapReduce库如何处理函数的输出。reduce函数的输出被写到最终的输出文件中。Combiner函数的输出被写到一个中间文件中，该文件将被发送到reduce任务中。</p>
<p>Partial combining significantly speeds up certain classes of MapReduce operations. Appendix A contains an example that uses a combiner.</p>
<p>一些Combiner函数大大加快了 MapReduce 的某些类操作的速度。附录 A 包含一个使用Combiner函数的例子。</p>
<h4 id="4-4-Input-and-Output-Types"><a href="#4-4-Input-and-Output-Types" class="headerlink" title="4.4 Input and Output Types"></a>4.4 Input and Output Types</h4><p>4.4 输入和输出类型</p>
<p>The MapReduce library provides support for reading in- put data in several different formats. For example, “text” mode input treats each line as a key/value pair: the key is the offset in the file and the value is the contents of the line. Another common supported format stores a sequence of key/value pairs sorted by key. Each input type implementation knows how to split itself into meaningful ranges for processing as separate map tasks (e.g. text mode’s range splitting ensures that range splits occur only at line boundaries). Users can add support for a new input type by providing an implementation of a simple reader interface, though most users just use one of a small number of predefined input types.</p>
<p>MapReduce 库提供多种不同格式的输入方式。例如，”文本”模式将每一行都视为一个键/值对：键是文件中的偏移量，值是该行的内容。另一种常见的格式是按键/值对排序的序列。每个输入类型的实现都明确如何将自身拆分成有意义的范围，作为单独的map任务进行处理（例如，文本模式的范围拆分可以确保拆分只发生在行边界）。用户可以通过提供一个简单的reader接口来增加对新输入类型的支持，尽管大多数用户仅仅需要用到预制的输入。</p>
<p>A reader does not necessarily need to provide data read from a file. For example, it is easy to define a reader that reads records from a database, or from data structures mapped in memory.</p>
<p>reader不一定要从文件中读取的数据。例如，很容易编写一个从数据库或者从内存中读取数据的reader。</p>
<p>In a similar fashion, we support a set of output types for producing data in different formats and it is easy for user code to add support for new output types.</p>
<p>同样，我们支持一组输出类型，用于产生不同格式的数据，用户也很容易添加对新的输出类型的支持。</p>
<h4 id="4-5-Side-effects"><a href="#4-5-Side-effects" class="headerlink" title="4.5 Side-effects"></a>4.5 Side-effects</h4><p>4.5 附加影响</p>
<p>In some cases, users of MapReduce have found it convenient to produce auxiliary files as additional outputs from their map and/or reduce operators. We rely on the application writer to make such side-effects atomic and idempotent. Typically the application writes to a temporary file and atomically renames this file once it has been fully generated.</p>
<p>在某些情况下，MapReduce的用户发现，在他们的map和reduce算子中产生辅助文件作为额外的输出很方便。我们通过编写代码来保证这种辅助效果的原子性和幂等性。通常情况下，应用程序会对一个临时文件写入，并在完全生成后对这个文件进行原子化重命名。</p>
<p>We do not provide support for atomic two-phase commits of multiple output files produced by a single task. Therefore, tasks that produce multiple output files with cross-file consistency requirements should be determin- istic. This restriction has never been an issue in practice.</p>
<p>我们不提供对单个任务产生的多个输出文件的两段性提交的原子支持。因此，对于产生多个输出文件的任务，如果有跨文件一致性要求的任务应该是确定性的。这个限制在实践中从未出现过问题。</p>
<h4 id="4-6-Skipping-Bad-Records"><a href="#4-6-Skipping-Bad-Records" class="headerlink" title="4.6 Skipping Bad Records"></a>4.6 Skipping Bad Records</h4><p>4.6 忽略损坏记录</p>
<p>Sometimes there are bugs in user code that cause the Map or Reduce functions to crash deterministically on certain records. Such bugs prevent a MapReduce operation from completing. The usual course of action is to fix the bug, but sometimes this is not feasible; perhaps the bug is in a third-party library for which source code is unavailable. Also, sometimes it is acceptable to ignore a few records, for example when doing statistical analysis on a large data set. We provide an optional mode of execution where the MapReduce library detects which records cause deterministic crashes and skips these records in order to make forward progress.</p>
<p>有时，用户代码中存在一些bug，导致Map或Reduce函数在处理某些记录时朋克。这种bug会阻碍MapReduce操作的完成。通常的做法是修复这个bug，但有时这并不起作用；也许这个bug存在于第三方库中，而源代码是不可修改的。另外，有时忽略一些记录也是可以接受的，例如在对一个大数据集进行统计分析时。我们提供了一种可选的执行模式，即MapReduce库检测到哪些记录会导致崩溃，并跳过这些记录继续执行。</p>
<p>Each worker process installs a signal handler that catches segmentation violations and bus errors. Before invoking a user Map or Reduce operation, the MapReduce library stores the sequence number of the argument in a global variable. If the user code generates a signal, the signal handler sends a “last gasp” UDP packet that contains the sequence number to the MapReduce master. When the master has seen more than one failure on a particular record, it indicates that the record should be skipped when it issues the next re-execution of the corresponding Map or Reduce task.</p>
<p>每个worker进程都安装了一个信号处理程序，用于捕获内存端异常和总线（bus）错误。在调用用户Map或Reduce操作之前，MapReduce库会将参数的序列号存储在一个全局变量中。如果用户代码产生了一个信号，信号处理程序就会向MapReduce master发送一个包含序列号的”回光返照（last gasp）”UDP数据包。当master在一个特定的记录上看到不止一次失败时，它会在下一次发出相应的Map或Reduce任务的重新执行时，表示该记录应该被跳过。</p>
<h4 id="4-7-Local-Execution"><a href="#4-7-Local-Execution" class="headerlink" title="4.7 Local Execution"></a>4.7 Local Execution</h4><p>4.7 本地执行</p>
<p>Debugging problems in Map or Reduce functions can be tricky, since the actual computation happens in a distributed system, often on several thousand machines, with work assignment decisions made dynamically by the master. To help facilitate debugging, profiling, and small-scale testing, we have developed an alternative implementation of the MapReduce library that sequentially executes all of the work for a MapReduce operation on the local machine. Controls are provided to the user so that the computation can be limited to particular map tasks. Users invoke their program with a special flag and can then easily use any debugging or testing tools they find useful (e.g. gdb).</p>
<p>调试Map或Reduce函数的一个很棘手的问题是实际的计算是在分布式系统中进行的，通常是在几千台机器上进行的，worker分配决定是由master动态地进行的。为了方便调试、分析和小规模测试，我们开发了一个MapReduce库的替代实现，在本地机器上依次执行MapReduce操作的所有工作。用户可以控制这些执行，以便将计算限制在特定的Map任务上。用户用一个特殊的标志来调用他们的程序，然后可以很容易地使用他们认为有用的任何调试或测试工具（如gdb）。</p>
<h4 id="4-8-Status-Information"><a href="#4-8-Status-Information" class="headerlink" title="4.8 Status Information"></a>4.8 Status Information</h4><p>4.8 状态信息</p>
<p>The master runs an internal HTTP server and exports a set of status pages for human consumption. The status pages show the progress of the computation, such as how many tasks have been completed, how many are in progress, bytes of input, bytes of intermediate data, bytes of output, processing rates, etc. The pages also contain links to the standard error and standard output files generated by each task. The user can use this data to pre- dict how long the computation will take, and whether or not more resources should be added to the computation. These pages can also be used to figure out when the computation is much slower than expected.</p>
<p>master运行一个内部的HTTP服务，并提供一组状态页面供人使用。状态页面显示了计算的进度，比如已经完成了多少个任务，有多少个任务正在进行中，输入的字节数、中间数据的字节数、输出的字节数、处理率等。这些页面还包含了每个任务产生的标准错误和标准输出文件的链接。用户可以使用这些数据来预判计算所需的时间，以及是否应该在计算中添加更多的资源。这些页面也可以用来提示计算速度比预期慢很多。</p>
<p>In addition, the top-level status page shows which workers have failed, and which map and reduce tasks they were processing when they failed. This information is useful when attempting to diagnose bugs in the user code.</p>
<p>此外，顶层的状态页面会显示哪些worker失败了，以及失败时他们正在处理哪些map和reduce任务。当试图诊断用户代码中的BUG时，这些信息很有用。</p>
<h4 id="4-9-Counters"><a href="#4-9-Counters" class="headerlink" title="4.9 Counters"></a>4.9 Counters</h4><p>4.9 计数器</p>
<p>The MapReduce library provides a counter facility to count occurrences of various events. For example, user code may want to count total number of words processed or the number of German documents indexed, etc.</p>
<p>MapReduce 库提供了一个计数器设施，用于统计各种事件的发生次数。例如，用户代码可能希望统计处理过的单词总数或索引的德语文档数量等。</p>
<p>To use this facility, user code creates a named counter object and then increments the counter appropriately in the Map and/or Reduce function. For example:</p>
<p>要使用这个功能，用户需要创建couter计数器对象，然后在Map和Reduce函数中适当地增加couter。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase = GetCounter(<span class="string">&quot;uppercase&quot;</span>);</span><br><span class="line"><span class="built_in">map</span>(String name, String contents):</span><br><span class="line">  <span class="keyword">for</span> each word w in contents:</span><br><span class="line"><span class="keyword">if</span> (IsCapitalized(w)): uppercase-&gt;Increment(); EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The counter values from individual worker machines are periodically propagated to the master (piggybacked on the ping response). The master aggregates the counter values from successful map and reduce tasks and returns them to the user code when the MapReduce operation is completed. The current counter values are also displayed on the master status page so that a human can watch the progress of the live computation. When aggregating counter values, the master eliminates the effects of duplicate executions of the same map or reduce task to avoid double counting. (Duplicate executions can arise from our use of backup tasks and from re-execution of tasks due to failures.)</p>
<p>来自单个worker的计数器值会周期性地发送到master（基于ping响应）。当MapReduce操作完成后，主站会将成功的map和reduce任务的计数器值汇总，并将其返回给用户代码。当前的计数器值也会显示在主站的状态页面上，这样用户就可以观察到实时计算的进度。在汇总计数器值时，master消除了同一Map或Reduce任务重复执行的影响，避免重复计算。(重复执行可能是由于我们使用备份任务和由于故障导致的任务重新执行而产生的)。</p>
<p>Some counter values are automatically maintained by the MapReduce library, such as the number of input key/value pairs processed and the number of output key/value pairs produced.</p>
<p>MapReduce 库会自动维护一些计数器的值，例如处理的输入键/值对的数量和产生的输出键/值对的数量。</p>
<p>Users have found the counter facility useful for sanity checking the behavior of MapReduce operations. For example, in some MapReduce operations, the user code may want to ensure that the number of output pairs produced exactly equals the number of input pairs processed, or that the fraction of German documents processed is within some tolerable fraction of the total number of documents processed.</p>
<p>用户发现计数器工具对于检查MapReduce操作的行为很有用。例如，在某些 MapReduce 操作中，用户代码可能希望确保所产生的输出对数正好等于所处理的输入对数，或者确保所处理的德文文档的数量在所处理的文档总数中的合理范围内。</p>
<h3 id="5-Performance"><a href="#5-Performance" class="headerlink" title="5 Performance"></a>5 Performance</h3><p>5 性能</p>
<p>In this section we measure the performance of MapReduce on two computations running on a large cluster of machines. One computation searches through approximately one terabyte of data looking for a particular pattern. The other computation sorts approximately one terabyte of data.</p>
<p>在这一节中，我们通过两个计算测试了MapReduce在大型集群上的表现。一个计算通过大约1TB的数据搜索，寻找一个特定的模式。另一个计算则对大约1TB的数据进行排序。</p>
<h4 id="5-1-Cluster-Configuration"><a href="#5-1-Cluster-Configuration" class="headerlink" title="5.1 Cluster Configuration"></a>5.1 Cluster Configuration</h4><p>5.1 集群配置</p>
<p>All of the programs were executed on a cluster that consisted of approximately 1800 machines. Each machine had two 2GHz Intel Xeon processors with Hyper-Threading enabled, 4GB of memory, two 160GB IDE disks, and a gigabit Ethernet link. The machines were arranged in a two-level tree-shaped switched network with approximately 100-200 Gbps of aggregate bandwidth available at the root. All of the machines were in the same hosting facility and therefore the round-trip time between any pair of machines was less than a millisecond.</p>
<p>所有的程序都是在一个由大约1800台机器组成的集群中执行的。每台机器都有两个2GHz的Intel Xeon处理器，启用了超线程，4GB的内存，两个160GB的IDE磁盘和一个千兆以太网链路。这些机器被安排在一个两层树状交换网络中，根部有大约100-200Gbps的总带宽。所有的机器都在同一个托管设施中，因此任何一对机器之间的往返时间都不到一毫秒。</p>
<p>Out of the 4GB of memory, approximately 1-1.5GB was reserved by other tasks running on the cluster. The programs were executed on a weekend afternoon, when the CPUs, disks, and network were mostly idle.</p>
<p>在4GB的内存中，大约有1-1.5GB的内存被集群上运行的其他任务预留了。这些程序是在一个周末的下午执行的，当时CPU、磁盘和网络大部分都是空闲的。</p>
<h4 id="5-2-Grep"><a href="#5-2-Grep" class="headerlink" title="5.2 Grep"></a>5.2 Grep</h4><p>5.2 Grep</p>
<p>The grep program scans through 1010 100-byte records, searching for a relatively rare three-character pattern (the pattern occurs in 92,337 records). The input is split into approximately 64MB pieces (M = 15000), and the entire output is placed in one file (R = 1).</p>
<p>grep程序扫描了1010条100字节的记录，寻找一个相对罕见的三字符模式（该模式出现在92,337条记录中）。输入被分割成大约64MB(M = 15000)，整个输出被放在一个文件中(R = 1)。</p>
<p>Figure 2 shows the progress of the computation over time. The Y-axis shows the rate at which the input data is scanned. The rate gradually picks up as more machines are assigned to this MapReduce computation, and peaks at over 30 GB/s when 1764 workers have been assigned. As the map tasks finish, the rate starts dropping and hits zero about 80 seconds into the computation. The entire computation takes approximately 150 seconds from start to finish. This includes about a minute of startup overhead. The overhead is due to the propagation of the program to all worker machines, and delays interacting with GFS to open the set of 1000 input files and to get the information needed for the locality optimization.</p>
<p>图2显示了计算进度随时间的变化。Y轴显示的是扫描输入数据的速度。随着越来越多的机器被分配到这个MapReduce计算中，速度逐渐加快，当分配到1764个worker时，速度达到了30GB/s以上的峰值。随着map任务的完成，速率开始下降，并在计算过程中约80秒后降至零。整个计算从开始到结束大约需要150秒。这包括了大约一分钟的启动开销。这些开销是由于程序传播到所有的工作机，以及与GFS交互以打开1000个输入文件集并获得定位优化所需的信息的延迟。</p>
<p><img src="https://images.haishenming.xyz/blog/Figure2.png" alt="Figure2"></p>
<h4 id="5-3-Sort"><a href="#5-3-Sort" class="headerlink" title="5.3 Sort"></a>5.3 Sort</h4><p>5.3 排序</p>
<p>The sort program sorts 10^10 100-byte records (approximately 1 terabyte of data). This program is modeled after the TeraSort benchmark.</p>
<p>该排序程序对10^10条100字节的记录（大约1TB的数据）进行排序。这个程序是以TeraSort为基准模型。</p>
<p>The sorting program consists of less than 50 lines of user code. A three-line Map function extracts a 10-byte sorting key from a text line and emits the key and the original text line as the intermediate key/value pair. We used a built-in Identity function as the Reduce operator. This functions passes the intermediate key/value pair unchanged as the output key/value pair. The final sorted output is written to a set of 2-way replicated GFS files (i.e., 2 terabytes are written as the output of the program).</p>
<p>该排序程序由不到50行的用户代码组成。一个三行Map函数从文本行中提取一个10字节的排序键，并将该键和原始文本行作为中间的键/值对发出。我们使用了一个内置的Identity函数作为Reduce操作器。该函数将中间键/值对直接输出。最终排序后的输出被写入一组双向复制的GFS文件中（即2TB作为程序的输出）。</p>
<p>As before, the input data is split into 64MB pieces (M = 15000). We partition the sorted output into 4000 files (R = 4000). The partitioning function uses the initial bytes of the key to segregate it into one of R pieces.</p>
<p>和之前一样，输入数据被分割成64MB块（M=15000）。我们将排序后的输出分割成4000个文件（R = 4000）。分区函数使用key的初始字节将其分割成R块中的一个块。</p>
<p>Our partitioning function for this benchmark has built- in knowledge of the distribution of keys. In a general sorting program, we would add a pre-pass MapReduce operation that would collect a sample of the keys and use the distribution of the sampled keys to compute splitpoints for the final sorting pass.</p>
<p>我们为这个基准的分区函数已经内置了关于key分布的知识。在一个一般的排序程序中，我们会添加一个预传值的MapReduce操作，该操作会收集一个key的样本，并使用采样key的分布来计算最终排序通过的分割点。</p>
<p><img src="https://images.haishenming.xyz/blog/20200430112150.png" alt="Figure3"></p>
<p>Figure 3 (a) shows the progress of a normal execution of the sort program. The top-left graph shows the rate at which input is read. The rate peaks at about 13 GB/s and dies off fairly quickly since all map tasks finish before 200 seconds have elapsed. Note that the input rate is less than for grep. This is because the sort map tasks spend about half their time and I/O bandwidth writing intermediate output to their local disks. The corresponding intermediate output for grep had negligible size.</p>
<p>图3（a）显示了正常执行排序程序的进度。左上图显示的是输入的读取速度。这个速度在13GB/s左右达到峰值，然后很快就消失了，因为所有的map任务都在200秒之前完成。请注意，输入速率比grep的输入速率要小。这是因为排序映射任务花了大约一半的时间和I/O带宽将中间输出写入本地磁盘。grep的相应的中间输出的大小可以忽略不计。</p>
<p>The middle-left graph shows the rate at which data is sent over the network from the map tasks to the reduce tasks. This shuffling starts as soon as the first map task completes. The first hump in the graph is for the first batch of approximately 1700 reduce tasks (the entire MapReduce was assigned about 1700 machines, and each machine executes at most one reduce task at a time). Roughly 300 seconds into the computation, some of these first batch of reduce tasks finish and we start shuffling data for the remaining reduce tasks. All of the shuffling is done about 600 seconds into the computation.</p>
<p>左中图显示了数据在网络上从map任务到reduce任务的速度。一旦第一个reduce任务完成，shuffle就开始了。图中的第一个驼峰是针对第一批大约1700个reduce任务（整个MapReduce分配给了大约1700台机器，每台机器每次最多执行一个reduce任务）。在计算执行大约300秒后，第一批reduce任务中的一些任务完成了，我们开始对剩余的reduce任务进行shuffle。所有的shuffle工作大约在计算结束后600秒左右完成。</p>
<p>The bottom-left graph shows the rate at which sorted data is written to the final output files by the reduce tasks. There is a delay between the end of the first shuffling pe- riod and the start of the writing period because the ma- chines are busy sorting the intermediate data. The writes continue at a rate of about 2-4 GB/s for a while. All of the writes finish about 850 seconds into the computation. Including startup overhead, the entire computation takes 891 seconds. This is similar to the current best reported result of 1057 seconds for the TeraSort benchmark.</p>
<p>左下图显示了reduce任务将排序后的数据写入最终输出文件的速度。从第一个shuffle结束到开始写入之间有一个延迟，因为机器忙于整理中间数据。写入的速度约为2-4 GB/s，持续了一段时间。所有的写入都在850秒左右完成计算。算上启动开销，整个计算时间为891秒。这与目前报告的TeraSort基准的最佳结果1057秒类似。</p>
<p>A few things to note: the input rate is higher than the shuffle rate and the output rate because of our locality optimization – most data is read from a local disk and bypasses our relatively bandwidth constrained network. The shuffle rate is higher than the output rate because the output phase writes two copies of the sorted data (we make two replicas of the output for reliability and availability reasons). We write two replicas because that is the mechanism for reliability and availability provided by our underlying file system. Network bandwidth requirements for writing data would be reduced if the un- derlying file system used erasure coding rather than replication.</p>
<p>有几件事需要注意：输入率高于shuffle速率和输出速率，因为我们进行了定位优化–大部分数据是从本地磁盘读取，绕过了我们相对受带宽限制的网络。shuffle速率高于输出速率，因为输出阶段输出了两份排序后的数据（出于可靠性和可用性的考虑，我们对输出做了两个副本）。我们输出两个副本，因为这是我们的底层文件系统提供的可靠性和可用性机制。如果非依赖文件系统使用擦除编码而不是复制，那么写数据的网络带宽要求就会降低。</p>
<h4 id="5-4-Effect-of-Backup-Tasks"><a href="#5-4-Effect-of-Backup-Tasks" class="headerlink" title="5.4 Effect of Backup Tasks"></a>5.4 Effect of Backup Tasks</h4><p>5.4 备份任务的效率</p>
<p>In Figure 3 (b), we show an execution of the sort pro- gram with backup tasks disabled. The execution flow is similar to that shown in Figure 3 (a), except that there is a very long tail where hardly any write activity occurs. After 960 seconds, all except 5 of the reduce tasks are completed. However these last few stragglers don’t finish until 300 seconds later. The entire computation takes 1283 seconds, an increase of 44% in elapsed time.</p>
<p>在图3(b)中，我们展示了一个在禁用备份任务的情况下执行的排序程序。执行流程与图3(a)中所示的类似，只是有一个很长的尾部，几乎没有任何写入活动发生。960秒后，除了5个Reduce任务外，其他的任务都已经完成。然而，这最后的几条尾巴直到300秒后才完成。整个计算耗时1283秒，耗时增加了44%。</p>
<h4 id="5-5-Machine-Failures"><a href="#5-5-Machine-Failures" class="headerlink" title="5.5 Machine Failures"></a>5.5 Machine Failures</h4><p>5.5 机器故障</p>
<p>In Figure 3 (c), we show an execution of the sort program where we intentionally killed 200 out of 1746 worker processes several minutes into the computation. The underlying cluster scheduler immediately restarted new worker processes on these machines (since only the processes were killed, the machines were still functioning properly).</p>
<p>在图3(c)中，我们展示了一个排序程序的执行情况，在计算的几分钟内，我们故意杀死了1746个工作进程中的200个进程。底层的集群调度器立即在这些机器上重新启动了新的工作进程（因为只有这些进程被杀死了，所以这些机器仍在正常运行）。</p>
<p>The worker deaths show up as a negative input rate since some previously completed map work disappears (since the corresponding map workers were killed) and needs to be redone. The re-execution of this map work happens relatively quickly. The entire computation finishes in 933 seconds including startup overhead (just an increase of 5% over the normal execution time).</p>
<p>worker的死亡显示为负输入率，因为之前完成的一些map工作会消失(因为相应的map worker被杀死)，需要重做。这个map工作的重新执行速度相对较快。整个计算工作在933秒内完成，包括启动开销（只是比正常执行时间增加了5%）。</p>
<h3 id="6-Experience"><a href="#6-Experience" class="headerlink" title="6 Experience"></a>6 Experience</h3><p>6 经验</p>
<p>We wrote the first version of the MapReduce library in February of 2003, and made significant enhancements to it in August of 2003, including the locality optimization, dynamic load balancing of task execution across worker machines, etc. Since that time, we have been pleasantly surprised at how broadly applicable the MapReduce library has been for the kinds of problems we work on. It has been used across a wide range of domains within Google, including:</p>
<p>我们在2003年2月编写了第一个版本的MapReduce库，并在2003年8月对其进行了重大的改进，包括定位优化、跨工作机执行任务的动态负载均衡等。从那时起，我们就惊喜地发现，MapReduce库在我们所处理的各类问题中的适用范围非常广泛。它已经在Google内部的各个领域中得到了广泛的应用，包括：</p>
<ul>
<li>large-scale machine learning problems</li>
<li>大型机器学习问题</li>
<li>clustering problems for the Google News and Froogle products</li>
<li>谷歌新闻和Froogle产品集群问题</li>
<li>extraction of data used to produce reports of popular queries (e.g. Google Zeitgeist)</li>
<li>提取数据用于生成流行查询报告（如Google Zeitgeist）</li>
<li>extractionofpropertiesofwebpagesfornewexper- iments and products (e.g. extraction of geographi- cal locations from a large corpus of web pages for localized search)</li>
<li>提取网页的属性（例如，从大量的网页语料库中提取地理位置以进行本地化搜索）</li>
<li>large-scale graph computations</li>
<li>大规模图计算</li>
</ul>
<p><img src="https://images.haishenming.xyz/blog/20200430114212.png" alt="Figure4"></p>
<p><img src="https://images.haishenming.xyz/blog/20200430114242.png" alt="Table1"></p>
<p>Figure 4 shows the significant growth in the number of separate MapReduce programs checked into our primary source code management system over time, from 0 in early 2003 to almost 900 separate instances as of late September 2004. MapReduce has been so successful because it makes it possible to write a simple program and run it efficiently on a thousand machines in the course of half an hour, greatly speeding up the development and prototyping cycle. Furthermore, it allows programmers who have no experience with distributed and/or parallel systems to exploit large amounts of resources easily.</p>
<p>图4显示了随着时间的推移，我们的主要源代码管理系统中的MapReduce程序数量的增长，从2003年年初的0到2004年9月底的近900个独立实例。MapReduce之所以如此成功，是因为它使我们可以在半小时内写出一个简单的程序并在上千台机器上高效运行，大大加快了开发和原型开发周期。此外，它使没有分布式或并行系统经验的程序员可以轻松地利用大量资源。</p>
<p>At the end of each job, the MapReduce library logs statistics about the computational resources used by the job. In Table 1, we show some statistics for a subset of MapReduce jobs run at Google in August 2004.</p>
<p>在每个作业结束后，MapReduce 库会记录有关该作业所使用的计算资源的统计数字。在表1中，我们展示了2004年8月在Google运行的MapReduce作业子集的一些统计数据。</p>
<h4 id="6-1-Large-Scale-Indexing"><a href="#6-1-Large-Scale-Indexing" class="headerlink" title="6.1 Large-Scale Indexing"></a>6.1 Large-Scale Indexing</h4><p>6.1 大规模索引</p>
<p>One of our most significant uses of MapReduce to date has been a complete rewrite of the production indexing system that produces the data structures used for the Google web search service. The indexing system takes as input a large set of documents that have been retrieved by our crawling system, stored as a set of GFS files. The raw contents for these documents are more than 20 terabytes of data. The indexing process runs as a sequence of five to ten MapReduce operations. Using MapReduce (instead of the ad-hoc distributed passes in the prior version fits:</p>
<p>迄今为止，我们对MapReduce最重要的应用之一是对生产索引系统进行了彻底的重写，该系统产生的数据结构用于Google网络搜索服务。该索引系统将我们的爬行系统检索到的大量文档作为输入，这些文档被存储为一组GFS文件。这些文档的原始内容超过20TB的数据。索引过程以五到十次MapReduce操作的顺序运行。使用MapReduce（而不是之前版本中的ad-hoc分布式通行证适合）:</p>
<ul>
<li><p>The indexing code is simpler, smaller, and easier to understand, because the code that deals with fault tolerance, distribution and parallelization is hidden within the MapReduce library. For example, the size of one phase of the computation dropped from approximately 3800 lines of C++ code to approximately 700 lines when expressed using MapReduce.</p>
</li>
<li><p>索引代码更简单、更小、更容易理解，因为处理容错、分配和并行化的代码隐藏在MapReduce库中。例如，使用MapReduce表示时，计算所使用的代码的大小从约3800行C++代码下降到约700行。</p>
</li>
<li><p>The performance of the MapReduce library is good enough that we can keep conceptually unrelated computations separate, instead of mixing them together to avoid extra passes over the data. This makes it easy to change the indexing process. For example, one change that took a few months to make in our old indexing system took only a few days to implement in the new system.</p>
</li>
<li><p>MapReduce库的性能足够好，我们可以把概念上不相关的计算分开，而不是把它们混在一起，避免了数据的额外传递。这使得我们很容易改变索引过程。例如，我们在旧的索引系统中花了几个月时间做的一个改变，在新系统中只用了几天时间就实现了。</p>
</li>
<li><p>The indexing process has become much easier to operate, because most of the problems caused by machine failures, slow machines, and networking hiccups are dealt with automatically by the MapReduce library without operator intervention. Furthermore, it is easy to improve the performance of the indexing process by adding new machines to the indexing cluster.</p>
</li>
<li><p>索引过程变得更加容易操作，因为大部分由机器故障、机器速度慢、网络故障等引起的问题都可以由MapReduce库自动处理，无需操作员干预。此外，通过在索引集群中添加新的机器，可以很容易地提高索引过程的性能。</p>
</li>
</ul>
<h3 id="7-Related-Work"><a href="#7-Related-Work" class="headerlink" title="7 Related Work"></a>7 Related Work</h3><p>7 相关工作</p>
<p>Many systems have provided restricted programming models and used the restrictions to parallelize the computation automatically. For example, an associative function can be computed over all prefixes of an N element array in log N time on N processors using parallel prefix computations. MapReduce can be considered a simplification and distillation of some of these models based on our experience with large real-world computations. More significantly, we provide a fault-tolerant implementation that scales to thousands of processors. In contrast, most of the parallel processing systems have only been implemented on smaller scales and leave the details of handling machine failures to the programmer.</p>
<p>许多系统都提供了限制性的编程模型，并利用这些限制来自动并行化计算。例如，一个关联函数可以在N个处理器上使用并行的前缀计算，在N个处理器上用对数组的所有前缀计算，用对数组的所有前缀计算时间为对数N个元素数组的所有前缀。MapReduce可以被认为是基于我们在现实世界中对大型计算的经验所得的模型，并对这些模型的一些简化和提炼。更重要的是，我们提供了一个可扩展到数千个处理器的容错实现。相比之下，大多数的并行处理系统只在较小的规模上实现，而将处理机器故障的细节留给了程序员。</p>
<p>Bulk Synchronous Programming and some MPI primitives provide higher-level abstractions that make it easier for programmers to write parallel pro- grams. A key difference between these systems and MapReduce is that MapReduce exploits a restricted programming model to parallelize the user program automatically and to provide transparent fault-tolerance.</p>
<p>Bulk 同步编程和一些MPI基元提供了更高级别的抽象，使程序员更容易编写并行程序。这些系统与MapReduce之间的一个关键区别是，MapReduce利用限制性的编程模型来自动并行化用户程序，并提供透明的容错能力。</p>
<p>Our locality optimization draws its inspiration from techniques such as active disks, where computation is pushed into processing elements that are close to local disks, to reduce the amount of data sent across I/O subsystems or the network. We run on commodity processors to which a small number of disks are directly connected instead of running directly on disk controller processors, but the general approach is similar.</p>
<p>我们的定位优化从主动磁盘等技术中获得了灵感，在这些技术中，计算被推送到靠近本地磁盘的处理元件中，以减少跨I/O子系统或网络发送的数据量。我们运行在直接连接少量磁盘的商品处理器上，而不是直接运行在磁盘控制器处理器上，但一般的方法是相似的。</p>
<p>Our backup task mechanism is similar to the eager scheduling mechanism employed in the Charlotte System. One of the shortcomings of simple eager scheduling is that if a given task causes repeated failures, the entire computation fails to complete. We fix some instances of this problem with our mechanism for skipping bad records.</p>
<p>我们的备份任务机制类似于夏洛特系统中采用的急切调度机制。简单的急切调度的缺点之一是，如果一个给定的任务导致重复失败，整个计算就会失败。我们用跳过不良记录的机制修复了这个问题。</p>
<p>The MapReduce implementation relies on an in-house cluster management system that is responsible for distributing and running user tasks on a large collection of shared machines. Though not the focus of this paper, the cluster management system is similar in spirit to other systems such as Condor.</p>
<p>MapReduce的实现依赖于一个内部的集群管理系统，该系统负责在大量共享机器的集合上分配和运行用户任务。虽然不是本文的重点，但这个集群管理系统与Condor等其他系统在精神上是相似的。</p>
<p>The sorting facility that is a part of the MapReduce library is similar in operation to NOW-Sort. Source machines (map workers) partition the data to be sorted and send it to one of R reduce workers. Each reduce worker sorts its data locally (in memory if possible). Of course NOW-Sort does not have the user-definable Map and Reduce functions that make our library widely applicable.</p>
<p>排序功能作为MapReduce库的一部分，其操作方式与NOW-Sort类似。源机器（map worker）对要排序的数据进行分区，并将其发送给R的一个reduce worker。每个reduce worker都会在本地（如果可能的话在内存中）对其数据进行排序。当然NOW-Sort并不具备用户定义的Map和Reduce函数，这使得我们的库广泛适用。</p>
<p>River provides a programming model where processes communicate with each other by sending data over distributed queues. Like MapReduce, the River system tries to provide good average case performance even in the presence of non-uniformities introduced by heterogeneous hardware or system perturbations. River achieves this by careful scheduling of disk and network transfers to achieve balanced completion times. MapReduce has a different approach. By restricting the programming model, the MapReduce framework is able to partition the problem into a large number of finegrained tasks. These tasks are dynamically scheduled on available workers so that faster workers process more tasks. The restricted programming model also allows us to schedule redundant executions of tasks near the end of the job which greatly reduces completion time in the presence of non-uniformities (such as slow or stuck workers).</p>
<p>River提供了一个编程模型，在这个模型中，进程之间通过分布式队列发送数据进行通信。与MapReduce一样，River系统试图提供良好的平均情况下的性能，即使是在异构硬件或系统扰动所带来的非均匀性的情况下也能实现。River通过精心调度磁盘和网络传输来实现这一目标，以实现平衡的完成时间。而MapReduce有一个不同的方法。通过限制编程模型，MapReduce框架能够将问题划分成大量的细粒度任务。这些任务被动态地安排在可用的worker上，这样，速度较快的worker就可以处理更多的任务。限制性编程模型还允许我们在任务接近结束时安排冗余的任务执行，这样可以在非均匀性（如慢的或卡住的worker）的情况下大大减少完成时间。</p>
<p>BAD-FS has a very different programming model from MapReduce, and unlike MapReduce, is targeted to the execution of jobs across a wide-area network. However, there are two fundamental similarities. (1) Both systems use redundant execution to recover from data loss caused by failures. (2) Both use locality-aware scheduling to reduce the amount of data sent across congested network links.</p>
<p>BAD-FS与MapReduce有一个非常不同的编程模型，与MapReduce不同的是，BAD-FS是针对广域网络中的作业执行。不过，两者有两个基本的相似之处。(1)两个系统都使用冗余执行来恢复故障造成的数据丢失。(2) 两者都使用本地化调度策略来减少在拥挤的网络链路上发送的数据量。</p>
<p>TACC is a system designed to simplify construction of highly-available networked services. Like MapReduce, it relies on re-execution as a mechanism for implementing fault-tolerance.</p>
<p>TACC是一个旨在简化构建高可用网络服务的系统。与MapReduce一样，它依赖于重执行作为实现容错机制。</p>
<h3 id="8-Conclusions"><a href="#8-Conclusions" class="headerlink" title="8 Conclusions"></a>8 Conclusions</h3><p>8 结论</p>
<p>The MapReduce programming model has been successfully used at Google for many different purposes. We attribute this success to several reasons. First, the model is easy to use, even for programmers without experience with parallel and distributed systems, since it hides the details of parallelization, fault-tolerance, locality optimization, and load balancing. Second, a large variety of problems are easily expressible as MapReduce computations. For example, MapReduce is used for the generation of data for Google’s production web search service, for sorting, for data mining, for machine learning, and many other systems. Third, we have developed an implementation of MapReduce that scales to large clusters of machines comprising thousands of machines. The implementation makes efficient use of these machine resources and therefore is suitable for use on many of the large computational problems encountered at Google.</p>
<p>MapReduce编程模型已经在Google成功地用于许多不同的目的。我们把这种成功归功于几个原因。首先，这个模型很容易使用，即使对于没有并行和分布式系统经验的程序员来说也很容易使用，因为它隐藏了并行化、容错、位置优化和负载平衡等细节。其次，大量的问题可以很容易地用MapReduce计算来表达。例如，MapReduce被用于Google生产的网络搜索服务的数据生成，用于排序，用于数据挖掘，用于机器学习等很多系统。第三，我们开发了一个MapReduce的实现，可以扩展到由成千上万台机器组成的大型机器集群。该实现有效地利用了这些机器资源，因此适合用于Google遇到的许多大型计算问题。</p>
<p>We have learned several things from this work. First, restricting the programming model makes it easy to parallelize and distribute computations and to make such computations fault-tolerant. Second, network bandwidth is a scarce resource. A number of optimizations in our system are therefore targeted at reducing the amount of data sent across the network: the locality optimization allows us to read data from local disks, and writing a single copy of the intermediate data to local disk saves network bandwidth. Third, redundant execution can be used to reduce the impact of slow machines, and to handle machine failures and data loss.</p>
<p>我们从这项工作中学到了几件事。首先，限制编程模型使并行化和分布式计算变得容易，并使这种计算具有容错性。其次，网络带宽是一种稀缺资源。因此，我们系统中的一些优化措施都是针对减少跨网络发送的数据量而进行的：定位性优化可以让我们从本地磁盘读取数据，将中间数据单拷贝写到本地磁盘上，节省了网络带宽。第三，冗余执行可以减少慢机的影响，处理机器故障和数据丢失等问题。</p>
<h3 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h3><p>致谢</p>
<p>Josh Levenberg has been instrumental in revising and extending the user-level MapReduce API with a number of new features based on his experience with using MapReduce and other people’s suggestions for enhancements. MapReduce reads its input from and writes its output to the Google File System. We would like to thank Mohit Aron, Howard Gobioff, Markus Gutschke,David Kramer, Shun-Tak Leung, and Josh Redstone for their work in developing GFS. We would also like to thank Percy Liang and Olcan Sercinoglu for their work in developing the cluster management system used by MapReduce. Mike Burrows, Wilson Hsieh, Josh Levenberg, Sharon Perl, Rob Pike, and Debby Wallach provided helpful comments on earlier drafts of this pa- per. The anonymous OSDI reviewers, and our shepherd, Eric Brewer, provided many useful suggestions of areas where the paper could be improved. Finally, we thank all the users of MapReduce within Google’s engineering organization for providing helpful feedback, suggestions, and bug reports.</p>
<p>Josh Levenberg根据他使用MapReduce的经验和其他人的改进建议，在修改和扩展用户级MapReduce API方面发挥了重要作用。MapReduce 从 Google 文件系统读取输入，并将其输出写入 Google 文件系统。我们要感谢 Mohit Aron、Howard Gobioff、Markus Gutschke、David Kramer、Shun-Tak Leung 和 Josh Redstone 为开发 GFS 所做的工作。我们还要感谢Percy Liang和Olcan Sercinoglu在开发MapReduce所使用的集群管理系统方面所做的工作。Mike Burrows、Wilson Hsieh、Josh Levenberg、Sharon Perl、Rob Pike 和 Debby Wallach 对本报告的早期草案提供了有益的意见。匿名的 OSDI 审稿人，以及我们的牧羊人 Eric Brewer 提供了许多有用的建议，对本文可以改进的地方提出了很多有用的建议。最后，我们感谢 Google 工程组织内所有 MapReduce 的用户提供了有用的反馈、建议和 bug 报告。</p>
<h3 id="A-Word-Frequency"><a href="#A-Word-Frequency" class="headerlink" title="A Word Frequency"></a>A Word Frequency</h3><p>附录A 词频统计</p>
<p>This section contains a program that counts the number of occurrences of each unique word in a set of input files specified on the command line.</p>
<p>本节包含一个程序，用于统计命令行上指定的一组输入文件中的每一个唯一的单词的出现次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mapreduce/mapreduce.h&quot;</span></span></span><br><span class="line"><span class="comment">// User’s map function </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> :</span> <span class="keyword">public</span> Mapper &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Map</span><span class="params">(<span class="keyword">const</span> MapInput&amp; input)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span>&amp; text = input.value(); <span class="keyword">const</span> <span class="keyword">int</span> n = text.size(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123; </span><br><span class="line">            <span class="comment">// Skip past leading whitespace </span></span><br><span class="line">            <span class="keyword">while</span> ((i &lt; n) &amp;&amp; <span class="built_in">isspace</span>(text[i])) </span><br><span class="line">               i++;</span><br><span class="line">            <span class="comment">// Find word end </span></span><br><span class="line">            <span class="keyword">int</span> start = i; </span><br><span class="line">            <span class="keyword">while</span> ((i &lt; n) &amp;&amp; !<span class="built_in">isspace</span>(text[i]))</span><br><span class="line">               i++;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; i) </span><br><span class="line">               Emit(text.substr(start,i-start),<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">REGISTER_MAPPER(WordCounter);</span><br><span class="line"><span class="comment">// User’s reduce function </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span> :</span> <span class="keyword">public</span> Reducer &#123; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reduce</span><span class="params">(ReduceInput* input)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// Iterate over all entries with the </span></span><br><span class="line">        <span class="comment">// same key and add the values </span></span><br><span class="line">        int64 value = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (!input-&gt;done()) &#123; </span><br><span class="line">            value += StringToInt(input-&gt;value()); </span><br><span class="line">            input-&gt;NextValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Emit sum for input-&gt;key() </span></span><br><span class="line">        Emit(IntToString(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">REGISTER_REDUCER(Adder);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123; </span><br><span class="line">    ParseCommandLineFlags(argc, argv);</span><br><span class="line">    MapReduceSpecification spec;</span><br><span class="line">    <span class="comment">// Store list of input files into &quot;spec&quot; </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123; </span><br><span class="line">        MapReduceInput* input = spec.add_input(); </span><br><span class="line">        input-&gt;set_format(<span class="string">&quot;text&quot;</span>); </span><br><span class="line">        input-&gt;set_filepattern(argv[i]); </span><br><span class="line">        input-&gt;set_mapper_class(<span class="string">&quot;WordCounter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Specify the output files: </span></span><br><span class="line">    <span class="comment">// /gfs/test/freq-00000-of-00100 </span></span><br><span class="line">    <span class="comment">// /gfs/test/freq-00001-of-00100 </span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    MapReduceOutput* out = spec.output();</span><br><span class="line">    out-&gt;set_filebase(<span class="string">&quot;/gfs/test/freq&quot;</span>); </span><br><span class="line">    out-&gt;set_num_tasks(<span class="number">100</span>); </span><br><span class="line">    out-&gt;set_format(<span class="string">&quot;text&quot;</span>); </span><br><span class="line">    out-&gt;set_reducer_class(<span class="string">&quot;Adder&quot;</span>);</span><br><span class="line">    <span class="comment">// Optional: do partial sums within map </span></span><br><span class="line">    <span class="comment">// tasks to save network bandwidth </span></span><br><span class="line">    out-&gt;set_combiner_class(<span class="string">&quot;Adder&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tuning parameters: use at most 2000 </span></span><br><span class="line">    <span class="comment">// machines and 100 MB of memory per task </span></span><br><span class="line"></span><br><span class="line">    spec.set_machines(<span class="number">2000</span>); </span><br><span class="line">    spec.set_map_megabytes(<span class="number">100</span>); </span><br><span class="line">    spec.set_reduce_megabytes(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now run it </span></span><br><span class="line">    MapReduceResult result; </span><br><span class="line">    <span class="keyword">if</span> (!MapReduce(spec, &amp;result)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done: ’result’ structure contains info</span></span><br><span class="line">    <span class="comment">// about counters, time taken, number of </span></span><br><span class="line">    <span class="comment">// machines used, etc.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>完！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xavierx.cn/2020/04/28/leetcode-%E5%88%A4%E6%96%AD%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xavier">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xavier's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/28/leetcode-%E5%88%A4%E6%96%AD%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">[leetcode]判断环形链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-28 09:31:00" itemprop="dateCreated datePublished" datetime="2020-04-28T09:31:00+08:00">2020-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 11:35:26" itemprop="dateModified" datetime="2021-07-16T11:35:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/submissions/">原题</a></p>
<p>既然是判断链表中有没有环，很容易想到，在遍历链表的时候，如果有环，则必会遇到重复的节点，因此可以使用hash表判断。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val  <span class="keyword">int</span></span><br><span class="line">	Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		_, ok := m[head]</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		m[head] = <span class="literal">true</span></span><br><span class="line">		head = head.Next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意题目下方要求用O(1)的空间复杂度解决，那么还可以考虑这样考虑，我们设置快慢两个指针，如果存在环，则慢指针必将追上快指针，因此可以这样写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val  <span class="keyword">int</span></span><br><span class="line">	Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slow := head</span><br><span class="line">	fast := head</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">		slow = slow.Next</span><br><span class="line">		fast = fast.Next.Next</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，我在题解区看到一种特别的解法,非常巧妙但是很沙雕，也分享出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;    <span class="comment">// 走自己的路让别人无路可走思路</span></span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head.Val == <span class="number">18464187</span> &#123;       <span class="comment">// 这是自己走过的路，说明有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        head.Val = <span class="number">18464187</span></span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 作者：elliotxx</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/8mskuai-man-zhi-zhen-hashsi-lu-de-go-shi-xian-by-e/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xavier</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xavier</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
